---
phase: 05-vs-code-extension
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - client/syntaxes/funlang.tmLanguage.json
  - client/snippets/funlang.json
  - client/language-configuration.json
  - client/package.json
autonomous: true

must_haves:
  truths:
    - "TextMate grammar tokenizes FunLang keywords, strings, comments, operators, and literals with correct scopes"
    - "Nested block comments (* outer (* inner *) still comment *) are scoped correctly"
    - "Multi-character operators (-> :: <> <= >= && ||) are tokenized as single tokens, not split"
    - "Language configuration supports line comment (//) and block comment (* *)"
    - "Auto-closing pairs work for parentheses, brackets, quotes, and block comments"
    - "onEnterRules continue // comments on new line"
    - "Six code snippets (let, letrec, if, match, fun, matchlist) expand with tabstop navigation"
    - "package.json contributes grammars, snippets, and language icon"
  artifacts:
    - path: "client/syntaxes/funlang.tmLanguage.json"
      provides: "TextMate grammar for FunLang syntax highlighting"
      min_lines: 80
    - path: "client/snippets/funlang.json"
      provides: "FunLang code snippets with tabstops"
      min_lines: 30
    - path: "client/language-configuration.json"
      provides: "Enhanced language config with block comments, onEnterRules, indentation"
      min_lines: 30
    - path: "client/package.json"
      provides: "Extension manifest with grammars, snippets, icon contributions"
  key_links:
    - from: "client/package.json"
      to: "client/syntaxes/funlang.tmLanguage.json"
      via: "contributes.grammars[0].path"
      pattern: "syntaxes/funlang.tmLanguage.json"
    - from: "client/package.json"
      to: "client/snippets/funlang.json"
      via: "contributes.snippets[0].path"
      pattern: "snippets/funlang.json"
    - from: "client/package.json"
      to: "client/language-configuration.json"
      via: "contributes.languages[0].configuration"
      pattern: "language-configuration.json"
---

<objective>
Create the TextMate grammar (EXT-01), enhanced language configuration (EXT-02), and code snippets (EXT-03) for the FunLang VS Code extension, and register them in package.json.

Purpose: These are the declarative contribution files that give FunLang syntax highlighting, comment toggling, bracket matching, and snippet expansion -- all without imperative code.
Output: syntaxes/funlang.tmLanguage.json, snippets/funlang.json, updated language-configuration.json, updated package.json with contributes section.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-vs-code-extension/05-RESEARCH.md
@client/package.json
@client/language-configuration.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TextMate grammar and code snippets</name>
  <files>client/syntaxes/funlang.tmLanguage.json, client/snippets/funlang.json</files>
  <action>
Create directories `client/syntaxes/` and `client/snippets/`.

**client/syntaxes/funlang.tmLanguage.json** -- TextMate grammar for FunLang:

```json
{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "FunLang",
  "scopeName": "source.funlang",
  "patterns": [
    { "include": "#comments" },
    { "include": "#strings" },
    { "include": "#constants" },
    { "include": "#keywords" },
    { "include": "#types" },
    { "include": "#operators" },
    { "include": "#identifiers" }
  ],
  "repository": { ... }
}
```

Token categories (derived from FunLang Lexer.fsl analysis):

1. **comments** repository:
   - Line comments: `"name": "comment.line.double-slash.funlang"`, `"match": "//.*$"`
   - Block comments (nestable): `"name": "comment.block.funlang"`, `"begin": "\\(\\*"`, `"end": "\\*\\)"`, with inner patterns including `#block-comment-nested`
   - `block-comment-nested`: Self-referencing for nesting support: `"name": "comment.block.nested.funlang"`, `"begin": "\\(\\*"`, `"end": "\\*\\)"`, patterns includes itself

2. **strings** repository:
   - `"name": "string.quoted.double.funlang"`, `"begin": "\""`, `"end": "\""`
   - Inner patterns for escape sequences: `"name": "constant.character.escape.funlang"`, `"match": "\\\\[nrt\\\\\"']"`

3. **constants** repository:
   - Integer literals: `"name": "constant.numeric.integer.funlang"`, `"match": "\\b[0-9]+\\b"`
   - Boolean literals: `"name": "constant.language.boolean.funlang"`, `"match": "\\b(true|false)\\b"`

4. **keywords** repository:
   - Control keywords: `"name": "keyword.control.funlang"`, `"match": "\\b(if|then|else|match|with|let|in|fun|rec)\\b"`
   - CRITICAL: Use `\b` word boundaries to prevent `letter` matching `let`, `infinity` matching `in`, etc.

5. **types** repository:
   - Type keywords: `"name": "support.type.funlang"`, `"match": "\\b(int|bool|string|list)\\b"`
   - Type variables: `"name": "variable.parameter.type.funlang"`, `"match": "'[a-zA-Z][a-zA-Z0-9_]*"`

6. **operators** repository (CRITICAL ORDERING: multi-char BEFORE single-char):
   - Arrow: `"name": "keyword.operator.arrow.funlang"`, `"match": "->"`
   - Cons: `"name": "keyword.operator.cons.funlang"`, `"match": "::"`
   - Comparison (multi-char first): `"name": "keyword.operator.comparison.funlang"`, `"match": "<>|<=|>=|<|>"`
   - Logical: `"name": "keyword.operator.logical.funlang"`, `"match": "&&|\\|\\|"`
   - Arithmetic: `"name": "keyword.operator.arithmetic.funlang"`, `"match": "[+\\-*/]"`
   - Assignment: `"name": "keyword.operator.assignment.funlang"`, `"match": "="`
   - Pipe (AFTER logical ||): `"name": "keyword.operator.pipe.funlang"`, `"match": "\\|"`

7. **identifiers** repository:
   - Wildcard: `"name": "variable.language.wildcard.funlang"`, `"match": "\\b_\\b"`

**client/snippets/funlang.json** -- Six FunLang snippets:

```json
{
  "Let Binding": {
    "prefix": "let",
    "body": ["let ${1:name} = ${2:value} in", "${0}"],
    "description": "Let binding expression"
  },
  "Recursive Function": {
    "prefix": "letrec",
    "body": ["let rec ${1:name} ${2:param} =", "\t${3:body}", "in", "${0}"],
    "description": "Recursive function definition"
  },
  "If-Then-Else": {
    "prefix": "if",
    "body": ["if ${1:condition}", "then ${2:consequent}", "else ${3:alternative}"],
    "description": "If-then-else expression"
  },
  "Match Expression": {
    "prefix": "match",
    "body": ["match ${1:expr} with", "| ${2:pattern} -> ${3:body}", "| ${4:_} -> ${0:default}"],
    "description": "Pattern match expression"
  },
  "Lambda": {
    "prefix": "fun",
    "body": ["fun ${1:x} -> ${0:body}"],
    "description": "Lambda expression"
  },
  "Match List": {
    "prefix": "matchlist",
    "body": ["match ${1:xs} with", "| [] -> ${2:base}", "| ${3:h} :: ${4:t} -> ${0:recursive}"],
    "description": "Pattern match on list (empty and cons)"
  }
}
```
  </action>
  <verify>
Both files exist. JSON syntax is valid: `cd /home/shoh/vibe-coding/LangLSP && node -e "JSON.parse(require('fs').readFileSync('client/syntaxes/funlang.tmLanguage.json'))"` and `node -e "JSON.parse(require('fs').readFileSync('client/snippets/funlang.json'))"` both succeed.
  </verify>
  <done>
TextMate grammar covers all FunLang tokens with correct scopes and operator ordering. Nested block comments use self-referencing pattern. Six snippets with tabstop placeholders created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update language-configuration.json and package.json</name>
  <files>client/language-configuration.json, client/package.json</files>
  <action>
**client/language-configuration.json** -- Replace with enhanced version:

```json
{
  "comments": {
    "lineComment": "//",
    "blockComment": ["(*", "*)"]
  },
  "brackets": [
    ["[", "]"],
    ["(", ")"]
  ],
  "autoClosingPairs": [
    { "open": "[", "close": "]" },
    { "open": "(", "close": ")" },
    { "open": "\"", "close": "\"", "notIn": ["string"] },
    { "open": "(*", "close": "*)", "notIn": ["string"] }
  ],
  "surroundingPairs": [
    ["[", "]"],
    ["(", ")"],
    ["\"", "\""]
  ],
  "autoCloseBefore": ";:.,=}])>` \n\t",
  "onEnterRules": [
    {
      "beforeText": "^\\s*\\/\\/.*$",
      "action": { "indent": "none", "appendText": "// " }
    }
  ],
  "indentationRules": {
    "increaseIndentPattern": "\\b(let|if|then|else|match|with|fun)\\b.*$",
    "decreaseIndentPattern": "^\\s*\\b(in|else|with)\\b"
  }
}
```

Changes from current:
- ADD `"blockComment": ["(*", "*)"]` to comments section
- REMOVE `["{", "}"]` from brackets (FunLang does not use curly braces)
- REMOVE `{ "open": "{", "close": "}" }` from autoClosingPairs
- REMOVE `["{", "}"]` from surroundingPairs
- ADD `{ "open": "(*", "close": "*)", "notIn": ["string"] }` to autoClosingPairs
- ADD `autoCloseBefore` field
- ADD `onEnterRules` for `//` comment continuation
- ADD `indentationRules` for FunLang keywords
- REMOVE `folding` section (region-based folding not needed for FunLang)

**client/package.json** -- Update the `contributes` section and add `icon`:

Add to top level:
- `"icon": "images/funlang-icon.png"`

Replace `contributes` section with:
```json
"contributes": {
  "languages": [{
    "id": "funlang",
    "aliases": ["FunLang", "funlang"],
    "extensions": [".fun"],
    "configuration": "./language-configuration.json",
    "icon": {
      "light": "./images/funlang-icon.png",
      "dark": "./images/funlang-icon.png"
    }
  }],
  "grammars": [{
    "language": "funlang",
    "scopeName": "source.funlang",
    "path": "./syntaxes/funlang.tmLanguage.json"
  }],
  "snippets": [{
    "language": "funlang",
    "path": "./snippets/funlang.json"
  }]
}
```

Keep ALL other fields unchanged (name, displayName, description, version, publisher, engines, activationEvents, main, scripts, dependencies, devDependencies).

Create a placeholder icon: `client/images/funlang-icon.png`. Generate a simple 128x128 PNG using a Node.js script or use a minimal valid PNG. The icon should be a simple solid-color square with "FL" text if possible, or at minimum a valid 128x128 PNG file. If generating a complex icon is difficult, create a minimal valid 1x1 PNG and document that a proper icon should replace it.

IMPORTANT: The `icon` field at the top level of package.json is what vsce uses for the extension icon in the Extensions panel. The `languages[0].icon` is for file icon theming.
  </action>
  <verify>
`cd /home/shoh/vibe-coding/LangLSP && node -e "const p = JSON.parse(require('fs').readFileSync('client/package.json')); console.log(p.contributes.grammars[0].path); console.log(p.contributes.snippets[0].path); console.log(p.icon);"` outputs the correct paths. `client/images/funlang-icon.png` exists.
  </verify>
  <done>
language-configuration.json has block comments, FunLang-specific brackets (no curly braces), auto-closing (* *), onEnterRules for // continuation, and indentation rules. package.json contributes grammars, snippets, and icon. Extension icon placeholder created.
  </done>
</task>

</tasks>

<verification>
```bash
# Validate all JSON files
cd /home/shoh/vibe-coding/LangLSP
node -e "JSON.parse(require('fs').readFileSync('client/syntaxes/funlang.tmLanguage.json'))"
node -e "JSON.parse(require('fs').readFileSync('client/snippets/funlang.json'))"
node -e "JSON.parse(require('fs').readFileSync('client/language-configuration.json'))"
node -e "const p = JSON.parse(require('fs').readFileSync('client/package.json')); console.log('grammars:', p.contributes.grammars.length); console.log('snippets:', p.contributes.snippets.length);"
# TypeScript compiles
cd client && npm run compile
```
</verification>

<success_criteria>
- EXT-01 met: TextMate grammar with correct scopes for all FunLang tokens
- EXT-02 met: Language config with block comments, auto-closing pairs, onEnterRules
- EXT-03 met: Six snippets (let, letrec, if, match, fun, matchlist) with tabstops
- All JSON files valid
- package.json registers all contribution points
- TypeScript still compiles (extension.ts unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/05-vs-code-extension/05-01-SUMMARY.md`
</output>
