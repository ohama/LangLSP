---
phase: 05-vs-code-extension
plan: 05
type: execute
wave: 4
depends_on: ["05-03"]
files_modified:
  - documentation/tutorial/12-vscode-extension.md
autonomous: true

must_haves:
  truths:
    - "Tutorial explains VS Code extension architecture (package.json, contributes, activation)"
    - "Tutorial shows TextMate grammar creation with FunLang token examples"
    - "Tutorial explains language-configuration.json with comment toggling and bracket matching"
    - "Tutorial demonstrates snippet creation with tabstop placeholders"
    - "Tutorial walks through VSIX packaging with dotnet publish and vsce package"
    - "Tutorial shows local installation and verification steps"
    - "Tutorial includes working code examples that match actual implementation"
  artifacts:
    - path: "documentation/tutorial/12-vscode-extension.md"
      provides: "VS Code Extension packaging tutorial in Korean (TUT-12)"
      min_lines: 500
  key_links:
    - from: "documentation/tutorial/12-vscode-extension.md"
      to: "client/syntaxes/funlang.tmLanguage.json"
      via: "code examples matching implementation"
      pattern: "tmLanguage|scopeName|TextMate"
    - from: "documentation/tutorial/12-vscode-extension.md"
      to: "client/package.json"
      via: "contributes section examples"
      pattern: "contributes|grammars|snippets"
    - from: "documentation/tutorial/12-vscode-extension.md"
      to: "client/src/extension.ts"
      via: "extension entry point examples"
      pattern: "extension.ts|activate|ServerOptions"
---

<objective>
Write the VS Code Extension packaging tutorial in Korean (TUT-12) explaining how to create, configure, and package a VS Code extension for a language server.

Purpose: Tutorial readers learn how to take a working LSP server and wrap it in a complete VS Code extension with syntax highlighting, language configuration, snippets, and VSIX distribution.
Output: documentation/tutorial/12-vscode-extension.md (~600-900 lines, Korean)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-vs-code-extension/05-RESEARCH.md
@client/package.json
@client/src/extension.ts
@client/syntaxes/funlang.tmLanguage.json
@client/snippets/funlang.json
@client/language-configuration.json
@client/.vscodeignore
@documentation/tutorial/11-code-actions.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write VS Code Extension packaging tutorial (12-vscode-extension.md)</name>
  <files>documentation/tutorial/12-vscode-extension.md</files>
  <action>
Create `documentation/tutorial/12-vscode-extension.md` in Korean, following the style and format of existing tutorials (especially 11-code-actions.md for most recent style reference).

Title: `# VS Code Extension 패키징`

Opening paragraph: Explain that this is the final tutorial in the series. We have built a complete Language Server with diagnostics, hover, completion, go to definition, find references, rename, and code actions. Now we will package it as a VS Code extension that anyone can install. This tutorial covers TextMate grammar for syntax highlighting, language configuration, code snippets, and VSIX packaging.

Structure:

## 목차
1. VS Code Extension 구조
2. TextMate Grammar
3. Language Configuration
4. 코드 스니펫
5. package.json Contributes 설정
6. Extension 진입점 (extension.ts)
7. VSIX 패키징
8. 로컬 설치 및 테스트
9. 정리

## Content for each section:

**1. VS Code Extension 구조**
- Extension anatomy: package.json (manifest), extension.ts (entry point), contributed files
- How VS Code loads extensions: activationEvents, contributes, main entry
- Our extension structure diagram:
  ```
  client/
  ├── package.json           # 확장 매니페스트
  ├── language-configuration.json  # 언어 설정
  ├── src/extension.ts       # LSP 클라이언트 진입점
  ├── out/extension.js       # 컴파일된 JS
  ├── syntaxes/              # 문법 정의
  │   └── funlang.tmLanguage.json
  ├── snippets/              # 코드 스니펫
  │   └── funlang.json
  ├── images/                # 확장 아이콘
  │   └── funlang-icon.png
  └── server/                # 패키징 시 LSP 서버 바이너리
      └── LangLSP.Server
  ```
- Explain: declarative (JSON config) vs imperative (extension.ts code) contributions

**2. TextMate Grammar**
- What is TextMate grammar: regex-based tokenization for syntax highlighting
- Explain scopeName, patterns, repository structure
- Walk through each token category with FunLang examples:
  - Comments (line and nestable block)
  - Strings with escape sequences
  - Constants (numbers, booleans)
  - Keywords (with `\b` word boundary importance)
  - Type keywords and type variables
  - Operators (CRITICAL: multi-char before single-char ordering)
  - Identifiers (wildcard `_`)
- Show actual funlang.tmLanguage.json code with explanations
- PITFALL callout: keyword matching without word boundaries (`letter` matching `let`)
- PITFALL callout: nested block comments requiring self-referencing pattern
- PITFALL callout: operator ordering (`->` must come before `-`)
- How to test: VS Code "Developer: Inspect Editor Tokens and Scopes" command

**3. Language Configuration**
- What language-configuration.json controls: comment toggling, bracket matching, auto-closing, indentation
- Walk through each section:
  - `comments`: lineComment `//` and blockComment `(* *)`
  - `brackets`: only `[`, `]` and `(`, `)` (not `{`, `}` -- FunLang does not use curly braces)
  - `autoClosingPairs`: including `(* *)` pair
  - `surroundingPairs`: for selection wrapping
  - `onEnterRules`: `//` comment continuation on Enter
  - `indentationRules`: increase after `let`, `if`, etc.; decrease on `in`, `else`
- Show actual language-configuration.json code
- Test: Ctrl+/ for line comment, Ctrl+Shift+A for block comment

**4. 코드 스니펫**
- VS Code snippet format: prefix, body (with `$1`, `${1:placeholder}`), description
- Walk through each FunLang snippet:
  - `let` -- Let binding
  - `letrec` -- Recursive function
  - `if` -- If-then-else
  - `match` -- Pattern match
  - `fun` -- Lambda
  - `matchlist` -- List pattern match
- Show actual snippets/funlang.json code with tabstop explanations
- How tabstops work: `$1` first stop, `$2` second, `$0` final cursor position
- PITFALL callout: escaping `$` and `}` in snippet bodies

**5. package.json Contributes 설정**
- The `contributes` field registers all declarative contributions
- Walk through each contribution point:
  - `languages`: id, aliases, extensions, configuration, icon
  - `grammars`: language, scopeName, path
  - `snippets`: language, path
- Show actual contributes section from package.json
- Other required fields: publisher, engines, icon, activationEvents
- Explain: empty activationEvents array with contributed languages triggers auto-activation (VS Code 1.74+)

**6. Extension 진입점 (extension.ts)**
- The extension.ts file is the imperative code that starts the LSP client
- Walk through the code:
  - Import vscode-languageclient
  - activate function: create ServerOptions and LanguageClientOptions
  - Production vs development mode detection (`fs.existsSync(serverDir)`)
  - deactivate function: stop the client
- Show actual extension.ts code with annotations
- Explain: why we use `dotnet run` in development but published binary in production

**7. VSIX 패키징**
- What is VSIX: VS Code extension package format (zip with manifest)
- Install @vscode/vsce: `npm install --save-dev @vscode/vsce`
- Three-step packaging process:
  1. `dotnet publish` the F# server to `client/server/`
  2. `npm run compile` to compile TypeScript
  3. `npx vsce package --allow-missing-repository` to create .vsix
- Show exact commands with output
- .vscodeignore: what to exclude (src/, node_modules/) and include (out/, server/, syntaxes/)
- Show actual .vscodeignore file
- Common errors: missing publisher, missing icon, missing files

**8. 로컬 설치 및 테스트**
- Install: `code --install-extension funlang-0.1.0.vsix`
- Verification checklist:
  1. Open .fun file -> syntax highlighting appears
  2. Ctrl+/ -> line comment toggle
  3. Type `(` -> `)` auto-closes
  4. Type `let` trigger -> snippet expands
  5. Hover -> type information
  6. Ctrl+Space -> completion
  7. F12 -> go to definition
  8. Shift+F12 -> find references
  9. F2 -> rename
  10. Lightbulb -> code actions
- Uninstall: `code --uninstall-extension funlang.funlang`
- Debug: VS Code Output panel -> FunLang Language Server

**9. 정리**
- Summary of what was built across all 12 tutorials
- The complete LSP feature set: diagnostics, hover, completion, definition, references, rename, code actions
- The complete extension: syntax highlighting, language config, snippets, VSIX packaging
- Where to go from here: Semantic Tokens, Inlay Hints, multi-file support, marketplace publishing

STYLE GUIDELINES (from existing tutorials):
- Korean language throughout
- Backtick code references for function names, types, file paths
- Fenced code blocks with language tags (json, typescript, bash, fsharp)
- Section dividers with ---
- Practical tone, concrete examples
- ~600-900 lines total
- Include actual implementation code (matching real files)
- Cross-reference LSP specification where relevant
- Reference previous tutorials where connections exist
  </action>
  <verify>
File exists at documentation/tutorial/12-vscode-extension.md with 500+ lines. Contains Korean text, all 9 sections, code examples from actual implementation files.
  </verify>
  <done>
Tutorial 12-vscode-extension.md written in Korean covering VS Code extension architecture, TextMate grammar, language configuration, snippets, package.json contributes, extension.ts, VSIX packaging, and installation testing (TUT-12).
  </done>
</task>

</tasks>

<verification>
- documentation/tutorial/12-vscode-extension.md exists with 500+ lines
- All 9 sections present
- Code examples match actual implementation files
- Korean language throughout
- Packaging commands are accurate and tested
</verification>

<success_criteria>
- TUT-12 requirement met: tutorial shows how to package VS Code extension as .vsix
- Tutorial follows established format from previous tutorials (11-code-actions.md style)
- Covers all Phase 5 topics: TextMate grammar, language config, snippets, packaging
- Code examples are accurate and match implementation
- Tutorial is the capstone of the series, referencing the full journey
</success_criteria>

<output>
After completion, create `.planning/phases/05-vs-code-extension/05-05-SUMMARY.md`
</output>
