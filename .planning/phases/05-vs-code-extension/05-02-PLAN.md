---
phase: 05-vs-code-extension
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/LangLSP.Tests/IntegrationTests.fs
  - src/LangLSP.Tests/LangLSP.Tests.fsproj
autonomous: true

must_haves:
  truths:
    - "Integration test simulates full LSP lifecycle: didOpen -> diagnostics -> hover -> completion -> definition -> references -> rename -> didClose"
    - "Integration test verifies correct LSP response structures (not just non-null)"
    - "All existing 116 tests still pass (no regressions)"
    - "Integration test demonstrates that all LSP features work together on the same document"
  artifacts:
    - path: "src/LangLSP.Tests/IntegrationTests.fs"
      provides: "End-to-end LSP integration tests"
      min_lines: 80
  key_links:
    - from: "src/LangLSP.Tests/IntegrationTests.fs"
      to: "LangLSP.Server.DocumentSync"
      via: "handleDidOpen/handleDidClose"
      pattern: "handleDidOpen|handleDidClose"
    - from: "src/LangLSP.Tests/IntegrationTests.fs"
      to: "LangLSP.Server.Diagnostics"
      via: "analyze function"
      pattern: "Diagnostics.analyze"
    - from: "src/LangLSP.Tests/IntegrationTests.fs"
      to: "LangLSP.Server.Hover"
      via: "handleHover"
      pattern: "handleHover"
    - from: "src/LangLSP.Tests/IntegrationTests.fs"
      to: "LangLSP.Server.Completion"
      via: "handleCompletion"
      pattern: "handleCompletion"
    - from: "src/LangLSP.Tests/IntegrationTests.fs"
      to: "LangLSP.Server.Definition"
      via: "handleDefinition"
      pattern: "handleDefinition"
    - from: "src/LangLSP.Tests/IntegrationTests.fs"
      to: "LangLSP.Server.References"
      via: "handleReferences"
      pattern: "handleReferences"
    - from: "src/LangLSP.Tests/IntegrationTests.fs"
      to: "LangLSP.Server.Rename"
      via: "handleRename"
      pattern: "handleRename"
---

<objective>
Create LSP integration tests (TEST-10) that verify the full request/response lifecycle across all LSP features on a single FunLang document.

Purpose: While existing unit tests verify each feature in isolation, integration tests prove all features work together on the same document through a realistic sequence of LSP operations.
Output: IntegrationTests.fs with end-to-end lifecycle tests, all passing alongside existing 116 tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-vs-code-extension/05-RESEARCH.md
@src/LangLSP.Tests/HoverTests.fs
@src/LangLSP.Tests/CompletionTests.fs
@src/LangLSP.Tests/DefinitionTests.fs
@src/LangLSP.Tests/ReferencesTests.fs
@src/LangLSP.Tests/RenameTests.fs
@src/LangLSP.Tests/LangLSP.Tests.fsproj
@src/LangLSP.Tests/Program.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IntegrationTests.fs with full LSP lifecycle test</name>
  <files>src/LangLSP.Tests/IntegrationTests.fs</files>
  <action>
Create `src/LangLSP.Tests/IntegrationTests.fs` as module `LangLSP.Tests.IntegrationTests`.

Opens: Expecto, Ionide.LanguageServerProtocol.Types, LangLSP.Server.DocumentSync, LangLSP.Server.Diagnostics, LangLSP.Server.Hover, LangLSP.Server.Completion, LangLSP.Server.Definition, LangLSP.Server.References, LangLSP.Server.Rename, LangLSP.Server.CodeActions

Use the EXACT test patterns from existing test modules (testSequenced, makeDidOpenParams, clearAll, Async.RunSynchronously).

Test FunLang source for integration testing (covers multiple features):
```fsharp
let testSource = "let add = fun x -> fun y -> x + y in\nlet result = add 1 2 in\nresult"
```

This source has:
- A function binding (`add`) with lambda parameters (`x`, `y`)
- A second let binding (`result`) that calls `add`
- Variable usages of `result`, `add`, `x`, `y`
- Binary operator (`+`)
- Integer literals
- Multi-line structure

Helper functions:
- `makeDidOpenParams uri text : DidOpenTextDocumentParams` -- same pattern as other test modules
- `makeHoverParams uri line char : TextDocumentPositionParams`
- `makeCompletionParams uri line char : CompletionParams` -- check existing CompletionTests for the exact type
- `makeDefinitionParams uri line char : TextDocumentPositionParams`
- `makeReferenceParams uri line char includeDecl : ReferenceParams`
- `makeRenameParams uri line char newName : RenameParams`
- `makeCodeActionParams uri diagnostics : CodeActionParams`

Test list (`testSequenced`, `testList "Integration"`):

**testList "LSP lifecycle":**

- "full lifecycle - open, analyze, hover, complete, definition, references, rename, close":
  Sequential test that exercises ALL features on a single document:
  1. clearAll()
  2. handleDidOpen with testSource at URI "file:///integration-test.fun"
  3. **Diagnostics**: Call `Diagnostics.analyze uri text` (where text = testSource). Expect no Error-severity diagnostics (the code is valid). May have warnings for unused variables.
  4. **Hover** on `add` (line 0, find the column for `add`): Call handleHover. Expect Some result with non-empty contents (type information for the function).
  5. **Completion** at line 1, column 0 (beginning of line 2): Call handleCompletion. Expect Some with completion items that include at least `add` (in-scope variable from line 1).
  6. **Go to Definition** on `add` in line 1 (in `add 1 2`): Call handleDefinition. Expect Some with location pointing back to line 0 where `add` is defined.
  7. **Find References** on `add` from line 0 definition, includeDecl=false: Call handleReferences. Expect at least 1 location (the usage in line 1).
  8. **Rename** `result` to `answer` at line 2 position: Call handleRename. Expect WorkspaceEdit with Changes containing edits that replace "result" with "answer".
  9. handleDidClose for the URI
  10. Verify getDocument returns None after close

  Each step: assert non-None result (or expected structure), use Expect.isTrue/Expect.isSome/Expect.equal as appropriate.

- "lifecycle with parse error - graceful degradation":
  1. clearAll()
  2. handleDidOpen with invalid source `"let x ="` (incomplete)
  3. Diagnostics.analyze: Expect at least one Error diagnostic
  4. Hover at (0, 4) on `x`: Expect None (parse failed, no AST)
  5. Completion at (0, 0): Expect Some with at least keyword completions (graceful degradation)
  6. Definition at (0, 4): Expect None
  7. References at (0, 4): Expect None
  8. handleDidClose

- "lifecycle with type error - diagnostics and code actions":
  1. clearAll()
  2. handleDidOpen with `"let x = 1 + true in x"`
  3. Diagnostics.analyze: Expect at least one type error diagnostic
  4. Hover on `x` (line 0, appropriate column in `in x`): Expect Some (even with type error, hover on successfully-parsed nodes may work, or None -- either is acceptable, just verify no crash)
  5. Code Actions: create CodeActionParams with the type error diagnostic, call handleCodeAction. Expect Some with at least one code action.
  6. handleDidClose

IMPORTANT: Use the SAME patterns as existing tests. Check existing test files for:
- Exact parameter construction (TextDocumentPositionParams may need specific field names)
- How clearAll() is called
- How async is handled (Async.RunSynchronously)
- How assertions are done (Expect.equal, Expect.isSome, Expect.isTrue)
  </action>
  <verify>
`dotnet build src/LangLSP.Tests/` compiles after Task 2 updates fsproj.
  </verify>
  <done>
IntegrationTests.fs has three lifecycle tests: full happy path (7 LSP operations), parse error graceful degradation, and type error with code actions. Tests exercise all LSP features on same document.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update test fsproj and verify all tests pass</name>
  <files>src/LangLSP.Tests/LangLSP.Tests.fsproj</files>
  <action>
**LangLSP.Tests.fsproj** -- Add IntegrationTests.fs to the Compile list, AFTER CodeActionsTests.fs and BEFORE Program.fs:

```xml
<Compile Include="CodeActionsTests.fs" />
<Compile Include="IntegrationTests.fs" />
<Compile Include="Program.fs" />
```

After updating fsproj, run all tests:
```bash
dotnet test src/LangLSP.Tests/ --verbosity normal
```

CRITICAL: All existing 116 tests MUST still pass. The integration tests add approximately 3 new tests. Expect total ~119 tests, zero failures.

If any integration test fails:
- Check that parameter construction matches existing test patterns
- Check that the test source code is valid FunLang (parse correctly)
- Verify column numbers match actual character positions (0-based)
- Adjust assertions to match actual return values (e.g., hover content format)
  </action>
  <verify>
```bash
dotnet test src/LangLSP.Tests/ --verbosity normal
# All tests pass (119+ total, 0 failures)
# Integration tests appear in test output
```
  </verify>
  <done>
IntegrationTests.fs added to fsproj. All tests pass including existing 116 and new integration tests. Zero regressions. TEST-10 requirement met.
  </done>
</task>

</tasks>

<verification>
```bash
dotnet test src/LangLSP.Tests/ --verbosity normal
# Expected: ~119 tests, 0 failures
# Integration tests verify full LSP lifecycle
# Existing 116 tests still pass
```
</verification>

<success_criteria>
- TEST-10 met: LSP integration tests verify full request/response lifecycle
- Integration tests cover: didOpen, diagnostics, hover, completion, definition, references, rename, code actions, didClose
- Graceful degradation verified: parse error does not crash LSP features
- All existing 116 tests still pass (no regressions)
- Tests follow project patterns (testSequenced, Expecto, Async.RunSynchronously)
</success_criteria>

<output>
After completion, create `.planning/phases/05-vs-code-extension/05-02-SUMMARY.md`
</output>
