---
phase: 04-advanced-features
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/LangLSP.Server/Rename.fs
  - src/LangLSP.Server/CodeActions.fs
  - src/LangLSP.Server/Diagnostics.fs
  - src/LangLSP.Server/Server.fs
  - src/LangLSP.Server/LangLSP.Server.fsproj
autonomous: true

must_haves:
  truths:
    - "handleRename collects all references + definition and returns WorkspaceEdit with TextEdit for each"
    - "handlePrepareRename validates cursor is on a renameable symbol and returns range + placeholder"
    - "Diagnostics.findUnusedVariables detects let-bound variables not referenced in body"
    - "handleCodeAction returns quickfix CodeAction to remove unused variable when diagnostic present"
  artifacts:
    - path: "src/LangLSP.Server/Rename.fs"
      provides: "Rename Symbol implementation"
      exports: ["handleRename", "handlePrepareRename"]
    - path: "src/LangLSP.Server/CodeActions.fs"
      provides: "Code Actions implementation"
      exports: ["handleCodeAction"]
    - path: "src/LangLSP.Server/Diagnostics.fs"
      provides: "Updated diagnostics with unused variable detection"
      exports: ["findUnusedVariables"]
  key_links:
    - from: "src/LangLSP.Server/Rename.fs"
      to: "References.collectReferencesForBinding"
      via: "import and call for collecting rename targets"
      pattern: "collectReferencesForBinding"
    - from: "src/LangLSP.Server/Rename.fs"
      to: "Protocol.createWorkspaceEdit"
      via: "import and call for building WorkspaceEdit"
      pattern: "createWorkspaceEdit"
    - from: "src/LangLSP.Server/CodeActions.fs"
      to: "Diagnostics context"
      via: "reads diagnostics from CodeActionParams.Context"
      pattern: "p\\.Context\\.Diagnostics"
    - from: "src/LangLSP.Server/Server.fs"
      to: "Rename and CodeActions handlers"
      via: "handler registration"
      pattern: "handleRename|handleCodeAction"
---

<objective>
Implement Rename Symbol (RENAME-01, RENAME-02, RENAME-03) and Code Actions (ACTION-01, ACTION-02) features.

Purpose: Users need to safely rename variables across all usages and receive quickfix suggestions for code issues. Rename builds on References (Plan 01), Code Actions integrate with diagnostics.
Output: Rename.fs with rename + prepareRename, CodeActions.fs with quickfix generation, Diagnostics.fs with unused variable detection, Server.fs fully registered.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-advanced-features/04-RESEARCH.md
@.planning/phases/04-advanced-features/04-01-SUMMARY.md
@src/LangLSP.Server/References.fs
@src/LangLSP.Server/Protocol.fs
@src/LangLSP.Server/Definition.fs
@src/LangLSP.Server/Diagnostics.fs
@src/LangLSP.Server/Server.fs
@src/LangLSP.Server/AstLookup.fs
@src/LangLSP.Server/LangLSP.Server.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Rename.fs with rename and prepareRename handlers</name>
  <files>src/LangLSP.Server/Rename.fs</files>
  <action>
Create `src/LangLSP.Server/Rename.fs` as module `LangLSP.Server.Rename`.

Open: Ionide.LanguageServerProtocol.Types, LangLSP.Server.AstLookup, LangLSP.Server.Definition, LangLSP.Server.References, LangLSP.Server.DocumentSync, LangLSP.Server.Protocol, Ast

Implement two functions:

1. `handlePrepareRename (p: PrepareRenameParams) : Async<PrepareRenameResult option>`
   - Get document from getDocument p.TextDocument.Uri
   - Parse AST from document text
   - Find node at p.Position with findNodeAtPosition
   - Match on node:
     - Var(name, span) -> return Some (U3.C2 { Range = spanToLspRange span; Placeholder = name })
     - Let(name, _, _, span) -> return Some (U3.C2 { Range = spanToLspRange span; Placeholder = name })
     - LetRec(name, _, _, _, span) -> return Some (U3.C2 { Range = spanToLspRange span; Placeholder = name })
     - Lambda(param, _, span) -> return Some (U3.C2 { Range = spanToLspRange span; Placeholder = param })
     - LambdaAnnot(param, _, _, span) -> return Some (U3.C2 { Range = spanToLspRange span; Placeholder = param })
     - _ -> return None (not a renameable symbol: numbers, keywords, operators)
   - Wrap in try/with _ -> return None

   NOTE on PrepareRenameParams: Check the Ionide 0.7.0 types. PrepareRenameParams may be `TextDocumentPositionParams` or a separate type. Use whatever type the library provides. The handler signature should match what Ionide expects.

2. `handleRename (p: RenameParams) : Async<WorkspaceEdit option>`
   - Get document from getDocument p.TextDocument.Uri
   - Parse AST
   - Find node at p.Position with findNodeAtPosition
   - Determine varName and defSpan:
     - If Var(name, _): look up definition with findDefinitionForVar name ast p.Position
     - If binding site (Let, LetRec, Lambda, LambdaAnnot): use node's own span as defSpan, get name from node
   - If no varName or no defSpan, return None
   - Collect scoped references: collectReferencesForBinding varName defSpan ast
   - Build allSpans = defSpan :: references (always include definition in rename)
   - Remove duplicates: List.distinctBy to avoid duplicate spans
   - Create TextEdit[] from allSpans: each edit replaces span range with p.NewName
     - Use Protocol.createTextEdit for each span
   - Create WorkspaceEdit: Protocol.createWorkspaceEdit p.TextDocument.Uri (Array.ofList edits)
   - Return Some workspaceEdit
   - Wrap in try/with _ -> return None

IMPORTANT: The rename must include the definition binding site AND all Var references. The definition span from collectDefinitions covers the whole Let expression — for rename, we need the span of just the identifier name, not the whole expression. This is a critical detail.

APPROACH for identifier-only spans: FunLang's AST stores spans for whole expressions (Let spans from "let" to end of body). For rename, we need to edit just the name part. Two options:
- Option A: Calculate the name span from the expression span (name starts at span.StartColumn + 4 for "let ", length = name.Length)
- Option B: For Var nodes, the span already covers just the variable name. For definitions, compute a name-only span.

Use Option B: For Var references, spans from collectReferences are already correct (Var spans cover just the name). For the definition site, compute a name-only span:
- Let: name starts at StartLine, StartColumn + 4 ("let " prefix), length = name.Length
- LetRec: name starts at StartColumn + 8 ("let rec " prefix), length = name.Length
- Lambda/LambdaAnnot: param position needs to be calculated from span

Actually, the simplest correct approach: Collect Var spans (which are tight around the name) for references. For the definition site, also collect the binding's name span. Since Definition.collectDefinitions returns (name, span) where span is the whole expression span, we cannot use it directly for rename edits.

REVISED APPROACH: Instead of using the definition span for the edit, use Hover.getWordAtPosition or a similar approach to find the exact character range of the identifier at the cursor. For all references (Var nodes), the spans are already correct. For the definition binding site, we need to create a synthetic span covering just the name. Compute it as:
- Search the source text at the definition line for the exact name occurrence
- Or: parse the first few characters of the definition expression to locate the name

SIMPLEST APPROACH: For rename, collect ALL Var references (these have tight spans). Then find the definition binding position. For the definition position, we know:
- Let(name, ..., span): the name starts at (span.StartLine, span.StartColumn + 4) for "let x" syntax
- LetRec(name, ..., span): the name starts at (span.StartLine, span.StartColumn + 8) for "let rec f" syntax
- Lambda(param, ..., span): the param starts at (span.StartLine, span.StartColumn + 4) for "fun x" syntax
- LambdaAnnot: same as Lambda

Create a helper function `getNameSpanFromBinding`:
```fsharp
let getNameSpanFromBinding (node: Expr) : (string * Span) option =
    match node with
    | Let(name, _, _, span) ->
        let nameSpan = { span with
            StartColumn = span.StartColumn + 4
            EndLine = span.StartLine
            EndColumn = span.StartColumn + 4 + name.Length - 1 }
        Some (name, nameSpan)
    | LetRec(name, _, _, _, span) ->
        let nameSpan = { span with
            StartColumn = span.StartColumn + 8
            EndLine = span.StartLine
            EndColumn = span.StartColumn + 8 + name.Length - 1 }
        Some (name, nameSpan)
    | Lambda(param, _, span) ->
        let nameSpan = { span with
            StartColumn = span.StartColumn + 4
            EndLine = span.StartLine
            EndColumn = span.StartColumn + 4 + param.Length - 1 }
        Some (param, nameSpan)
    | LambdaAnnot(param, _, _, span) ->
        let nameSpan = { span with
            StartColumn = span.StartColumn + 4
            EndLine = span.StartLine
            EndColumn = span.StartColumn + 4 + param.Length - 1 }
        Some (param, nameSpan)
    | _ -> None
```

Then in handleRename:
- If cursor is on Var: find definition via findDefinitionForVar, find the definition AST node, get its name span, collect all Var references
- If cursor is on binding: get name span directly, collect all Var references for that binding
- All edits: name span of binding + all Var spans -> TextEdit[] with NewText = p.NewName

Wait, there's a simpler way. The Var spans are already tight. The Definition.findDefinitionForVar returns the definition's expression span (whole Let span). We need to re-find the actual binding node in the AST to compute the name span. Or we can search the source text for the name at the definition position.

FINAL SIMPLEST APPROACH: Use source text search. Given the definition span from findDefinitionForVar:
1. Get the line from source text
2. Find the first occurrence of the variable name within the first ~10 chars of the span start
3. Create a span covering just that name

Implement a helper `findNameInSource (text: string) (name: string) (startLine: int) (startCol: int) : Span option`:
- Get the line from text.Split('\n')
- Search for name starting from startCol, within the first 15 characters (covers "let rec " + name)
- Return span with just the name's start/end positions

This avoids relying on AST span semantics for binding names.

Actually, let's step back. Let's look at what FunLang's AST actually gives us for Var nodes. The Var(name, span) span should cover just the variable name characters. That's what we need for references. For definitions, we need a different approach.

The simplest and most robust: scan the document text to find the exact character positions of the name at the definition location. This works regardless of AST span semantics.
  </action>
  <verify>
Module compiles: `dotnet build src/LangLSP.Server/` (after Task 2 adds to fsproj)
  </verify>
  <done>
Rename.fs has handlePrepareRename (validates renameable symbols, returns range+placeholder) and handleRename (collects all references + definition name span, returns WorkspaceEdit with all edits).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CodeActions.fs, update Diagnostics.fs, complete Server.fs</name>
  <files>src/LangLSP.Server/CodeActions.fs, src/LangLSP.Server/Diagnostics.fs, src/LangLSP.Server/Server.fs, src/LangLSP.Server/LangLSP.Server.fsproj</files>
  <action>
**Diagnostics.fs** — Add unused variable detection. Add after the existing `analyze` function:

```fsharp
/// Find unused variables in AST
/// Returns list of (name, span) for let-bound variables not referenced in their body
let findUnusedVariables (ast: Expr) : (string * Ast.Span) list =
    let unused = ResizeArray<string * Ast.Span>()

    let rec traverse expr =
        match expr with
        | Let(name, value, body, span) ->
            // Check if name appears as Var in body
            let refs = References.collectReferences name body
            if List.isEmpty refs && name <> "_" then
                // Compute name-only span: "let " is 4 chars
                let nameSpan : Ast.Span = {
                    FileName = span.FileName
                    StartLine = span.StartLine
                    StartColumn = span.StartColumn + 4
                    EndLine = span.StartLine
                    EndColumn = span.StartColumn + 4 + name.Length - 1
                }
                unused.Add(name, nameSpan)
            traverse value
            traverse body
        | LetRec(name, param, fnBody, inExpr, span) ->
            // For rec functions, check if name used in inExpr (not fnBody, since recursion)
            let refsInBody = References.collectReferences name inExpr
            if List.isEmpty refsInBody && name <> "_" then
                let nameSpan : Ast.Span = {
                    FileName = span.FileName
                    StartLine = span.StartLine
                    StartColumn = span.StartColumn + 8
                    EndLine = span.StartLine
                    EndColumn = span.StartColumn + 8 + name.Length - 1
                }
                unused.Add(name, nameSpan)
            traverse fnBody
            traverse inExpr
        | App(fn, arg, _) -> traverse fn; traverse arg
        | If(c, t, e, _) -> traverse c; traverse t; traverse e
        | Lambda(_, body, _) | LambdaAnnot(_, _, body, _) -> traverse body
        | LetPat(_, value, body, _) -> traverse value; traverse body
        | Match(scrutinee, clauses, _) ->
            traverse scrutinee
            for (_, clauseBody) in clauses do traverse clauseBody
        | Add(l,r,_) | Subtract(l,r,_) | Multiply(l,r,_) | Divide(l,r,_)
        | Equal(l,r,_) | NotEqual(l,r,_) | LessThan(l,r,_) | GreaterThan(l,r,_)
        | LessEqual(l,r,_) | GreaterEqual(l,r,_) | And(l,r,_) | Or(l,r,_)
        | Cons(l,r,_) -> traverse l; traverse r
        | Negate(e, _) | Annot(e, _, _) -> traverse e
        | Tuple(exprs, _) | List(exprs, _) -> List.iter traverse exprs
        | Number _ | Bool _ | String _ | Var _ | EmptyList _ -> ()

    traverse ast
    unused |> Seq.toList
```

IMPORTANT: Diagnostics.fs needs to `open LangLSP.Server.References` for collectReferences. But there's a circular dependency risk — References.fs opens Definition.fs, Diagnostics.fs already exists before References.fs in fsproj order. Check the compile order carefully. If circular, move findUnusedVariables to References.fs or a shared module instead.

Actually, looking at the fsproj order: Protocol -> AstLookup -> DocumentSync -> Hover -> Definition -> Completion -> References -> Diagnostics -> Server. So Diagnostics.fs compiles AFTER References.fs — no circular dependency. Add `open LangLSP.Server.References` to Diagnostics.fs.

Update the `analyze` function to also return unused variable warnings:

```fsharp
let analyze (uri: string) (source: string) : Diagnostic list =
    match parseFunLang source uri with
    | Error parseDiag -> [parseDiag]
    | Ok ast ->
        let typeErrors =
            match typecheckAst ast with
            | Ok _ -> []
            | Error typeDiag -> [typeDiag]

        let unusedWarnings =
            findUnusedVariables ast
            |> List.map (fun (name, nameSpan) ->
                {
                    Range = spanToLspRange nameSpan
                    Severity = Some DiagnosticSeverity.Warning
                    Code = Some (U2.C2 "unused-variable")
                    CodeDescription = None
                    Source = Some "funlang"
                    Message = sprintf "Unused variable '%s'" name
                    Tags = Some [| DiagnosticTag.Unnecessary |]
                    RelatedInformation = None
                    Data = None
                })

        typeErrors @ unusedWarnings
```

Key details:
- Severity is Warning (not Error) for unused variables
- Code is "unused-variable" (used by CodeActions to identify fixable diagnostics)
- Tags includes DiagnosticTag.Unnecessary (VS Code renders these as faded/dimmed)

**CodeActions.fs** — Create `src/LangLSP.Server/CodeActions.fs` as module `LangLSP.Server.CodeActions`:

Open: Ionide.LanguageServerProtocol.Types, LangLSP.Server.Protocol

Implement:

1. `createRemoveUnusedAction (diag: Diagnostic) (uri: string) : CodeAction`
   - Title: sprintf "Remove unused variable '%s'" (extract name from diag.Message — parse between single quotes)
   - Kind: Some "quickfix"
   - Diagnostics: Some [| diag |]
   - IsPreferred: Some true
   - Edit: Some (createWorkspaceEdit uri [| { Range = diag.Range; NewText = "" } |])
     Wait — removing just the variable name doesn't make sense. We need to remove the entire `let x = value in` part. For proper removal, we'd need the full Let expression span. But the diagnostic only has the name span.

   REVISED APPROACH for remove unused: The code action should suggest removing the entire let binding. But we only have the name span in the diagnostic. Two options:
   - A) Store the full Let span in diagnostic Data field
   - B) Re-parse and find the Let expression containing the unused variable
   - C) Just mark it as a hint, don't provide auto-edit (safest for Phase 4)

   Use approach C for Phase 4: Create a CodeAction with `kind = "quickfix"` but with a simple edit that comments out the binding or replaces the let expression. Actually, the safest quickfix is to prefix the variable name with underscore (convention for intentionally unused). This is a minimal, safe edit:

   ```fsharp
   let createPrefixUnderscoreAction (diag: Diagnostic) (uri: string) : CodeAction =
       // Extract variable name from message "Unused variable 'x'"
       let msg = diag.Message
       let nameStart = msg.IndexOf("'") + 1
       let nameEnd = msg.IndexOf("'", nameStart)
       let varName = msg.Substring(nameStart, nameEnd - nameStart)

       {
           Title = sprintf "Prefix '%s' with underscore" varName
           Kind = Some "quickfix"
           Diagnostics = Some [| diag |]
           IsPreferred = Some true
           Disabled = None
           Edit = Some (createWorkspaceEdit uri [| { Range = diag.Range; NewText = "_" + varName } |])
           Command = None
           Data = None
       }
   ```

2. `handleCodeAction (p: CodeActionParams) : Async<TextDocumentCodeActionResult option>`
   - Check p.Context.Diagnostics for fixable diagnostics
   - For each diagnostic with Source = Some "funlang":
     - If Code matches U2.C2 "unused-variable": create prefix underscore action
     - If Message contains "Type mismatch" (ACTION-02): for now, skip complex type fixes (add comment noting future work)
   - Return Some (actions as TextDocumentCodeActionResult) if any actions found, None otherwise

   NOTE: Check the Ionide 0.7.0 type for the return. It may be `Async<TextDocumentCodeActionResult option>` where TextDocumentCodeActionResult is `U2<Command, CodeAction>[]`. Create CodeAction wrapped in U2.C2:
   ```fsharp
   let result = actions |> Array.map U2.C2
   return Some result
   ```

**Server.fs** — Complete registration:

1. Add opens: `open LangLSP.Server.Rename`, `open LangLSP.Server.CodeActions`
2. Add to serverCapabilities:
   ```fsharp
   RenameProvider = Some (U2.C2 {
       PrepareProvider = Some true
       WorkDoneProgress = None
   })
   CodeActionProvider = Some (U2.C2 {
       CodeActionKinds = Some [| "quickfix" |]
       ResolveProvider = Some false
       WorkDoneProgress = None
   })
   ```
3. Add to Handlers module:
   ```fsharp
   let textDocumentRename (p: RenameParams) : Async<WorkspaceEdit option> =
       Rename.handleRename p

   let textDocumentPrepareRename (p: PrepareRenameParams) : Async<PrepareRenameResult option> =
       Rename.handlePrepareRename p

   let textDocumentCodeAction (p: CodeActionParams) : Async<TextDocumentCodeActionResult option> =
       CodeActions.handleCodeAction p
   ```

**LangLSP.Server.fsproj** — Add Rename.fs and CodeActions.fs to compile list. Order:
```xml
<Compile Include="References.fs" />
<Compile Include="Rename.fs" />
<Compile Include="CodeActions.fs" />
<Compile Include="Diagnostics.fs" />
```

Rename.fs must be after References.fs (imports it). CodeActions.fs must be after Protocol.fs (imports createWorkspaceEdit). Diagnostics.fs must be after References.fs (imports collectReferences).
  </action>
  <verify>
`dotnet build src/LangLSP.Server/` compiles without errors. All new modules linked. Server.fs has all 3 new capabilities registered (References from Plan 01, Rename, CodeAction).
  </verify>
  <done>
Rename.fs handles prepareRename (validates renameable symbol) and rename (builds WorkspaceEdit). CodeActions.fs generates quickfix for unused variables. Diagnostics.fs detects unused variables with Warning severity. Server.fs registers RenameProvider (with PrepareProvider), CodeActionProvider (quickfix kind).
  </done>
</task>

</tasks>

<verification>
```bash
dotnet build src/LangLSP.Server/
# Must compile with 0 errors
# All modules linked: References, Rename, CodeActions
# Server capabilities: ReferencesProvider, RenameProvider, CodeActionProvider
```
</verification>

<success_criteria>
- Rename.fs correctly collects references + definition and builds WorkspaceEdit
- prepareRename validates cursor is on Var, Let, LetRec, Lambda, or LambdaAnnot
- Diagnostics.fs detects unused let-bound variables (not underscore-prefixed)
- CodeActions.fs generates "prefix with underscore" quickfix for unused variables
- All capabilities registered in Server.fs
- Project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features/04-02-SUMMARY.md`
</output>
