---
phase: 04-advanced-features
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/LangLSP.Tests/ReferencesTests.fs
  - src/LangLSP.Tests/RenameTests.fs
  - src/LangLSP.Tests/CodeActionsTests.fs
  - src/LangLSP.Tests/LangLSP.Tests.fsproj
  - src/LangLSP.Tests/Program.fs
autonomous: true

must_haves:
  truths:
    - "Find References tests pass for variable usages (REF-01)"
    - "Find References tests pass for function call sites (REF-02)"
    - "Find References tests pass for includeDeclaration flag (REF-03)"
    - "Find References tests pass for variable shadowing edge case"
    - "Rename tests pass for renaming all variable occurrences (RENAME-01)"
    - "Rename tests pass for function rename (RENAME-02)"
    - "Rename prepareRename tests validate renameable symbols (RENAME-03)"
    - "Code Actions tests pass for unused variable quickfix (ACTION-01)"
    - "Code Actions tests pass for type error informational action (ACTION-02)"
    - "All existing 79 tests still pass (no regressions from unused variable detection)"
  artifacts:
    - path: "src/LangLSP.Tests/ReferencesTests.fs"
      provides: "Find References unit tests"
      min_lines: 80
    - path: "src/LangLSP.Tests/RenameTests.fs"
      provides: "Rename Symbol unit tests"
      min_lines: 80
    - path: "src/LangLSP.Tests/CodeActionsTests.fs"
      provides: "Code Actions unit tests"
      min_lines: 50
  key_links:
    - from: "src/LangLSP.Tests/ReferencesTests.fs"
      to: "References.handleReferences"
      via: "direct function call in tests"
      pattern: "handleReferences"
    - from: "src/LangLSP.Tests/RenameTests.fs"
      to: "Rename.handleRename"
      via: "direct function call in tests"
      pattern: "handleRename"
    - from: "src/LangLSP.Tests/CodeActionsTests.fs"
      to: "CodeActions.handleCodeAction"
      via: "direct function call in tests"
      pattern: "handleCodeAction"
---

<objective>
Write comprehensive unit tests for Find References (TEST-07), Rename Symbol (TEST-08), and Code Actions (TEST-09).

Purpose: Verify all three advanced features work correctly including edge cases like variable shadowing, non-renameable symbols, and diagnostic-driven quickfixes. Also verifies no regressions in existing tests from the Diagnostics.fs unused variable detection changes.
Output: ReferencesTests.fs, RenameTests.fs, CodeActionsTests.fs -- all passing with `dotnet test`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-advanced-features/04-01-SUMMARY.md
@.planning/phases/04-advanced-features/04-02-SUMMARY.md
@src/LangLSP.Server/References.fs
@src/LangLSP.Server/Rename.fs
@src/LangLSP.Server/CodeActions.fs
@src/LangLSP.Server/Diagnostics.fs
@src/LangLSP.Tests/DefinitionTests.fs
@src/LangLSP.Tests/CompletionTests.fs
@src/LangLSP.Tests/DiagnosticsTests.fs
@src/LangLSP.Tests/LangLSP.Tests.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ReferencesTests.fs and RenameTests.fs</name>
  <files>src/LangLSP.Tests/ReferencesTests.fs, src/LangLSP.Tests/RenameTests.fs</files>
  <action>
Follow the EXACT test patterns from DefinitionTests.fs and CompletionTests.fs (testSequenced, makeDidOpenParams, clearAll, Async.RunSynchronously).

**ReferencesTests.fs** -- module LangLSP.Tests.ReferencesTests

Opens: Expecto, Ionide.LanguageServerProtocol.Types, LangLSP.Server.References, LangLSP.Server.DocumentSync

Helper functions:
- `makeReferenceParams uri line char includeDecl : ReferenceParams` -- create params with TextDocument, Position, Context = { IncludeDeclaration = includeDecl }, WorkDoneToken = None, PartialResultToken = None
- `makeDidOpenParams uri text : DidOpenTextDocumentParams` -- same as other test modules
- `setupAndFindReferences uri text line char includeDecl` -- clearAll(), handleDidOpen, handleReferences |> Async.RunSynchronously

Test list (testSequenced, testList "References"):

testList "Variable references (REF-01)":
- "finds all variable usages": `let x = 1 in x + x` -- query at x usage (0, 14), includeDecl=false. Expect 2 locations (two Var x nodes in body)
- "finds single usage": `let y = 42 in y` -- query at y (0, 14), includeDecl=false. Expect 1 location
- "returns None for literal": `42` -- query at (0, 0), includeDecl=false. Expect None

testList "Function references (REF-02)":
- "finds function call sites": `let f = fun x -> x in f 1` -- query at f call (position of "f 1"), includeDecl=false. Should find at least the one call site
- "finds recursive function calls": `let rec fact n = if n = 0 then 1 else n * fact (n - 1) in fact 5` -- query at "fact 5" usage. Should find recursive call + final call

testList "Include declaration (REF-03)":
- "includes declaration when requested": `let x = 1 in x` -- query at x usage (0, 13), includeDecl=true. Expect more locations than includeDecl=false (definition included)
- "excludes declaration when not requested": same code, includeDecl=false. Expect only usage locations

testList "Variable shadowing":
- "handles shadowed variable - inner scope": `let x = 1 in let x = 2 in x` -- query at final x (0, 26), includeDecl=false. Expect 1 reference (only the inner x usage)
- "handles shadowed variable - outer scope": `let x = 1 in x + (let x = 2 in x)` -- query at first x in body (0, 13), includeDecl=false. Expect 1 reference (only the outer x usage)

testList "Edge cases":
- "returns None for unknown document": clearAll(), directly call handleReferences for missing URI. Expect None
- "returns None for parse error": `let x =` (incomplete). Expect None
- "all locations have correct URI": verify each location.Uri matches input URI

**RenameTests.fs** -- module LangLSP.Tests.RenameTests

Opens: Expecto, Ionide.LanguageServerProtocol.Types, LangLSP.Server.Rename, LangLSP.Server.DocumentSync

Helper functions:
- `makeRenameParams uri line char newName : RenameParams` -- TextDocument, Position, NewName, WorkDoneToken = None
- `makePrepareRenameParams uri line char : PrepareRenameParams` -- check Ionide type; may be TextDocumentPositionParams
- `makeDidOpenParams uri text`
- `setupAndRename uri text line char newName` -- clearAll, handleDidOpen, handleRename |> Async.RunSynchronously
- `setupAndPrepareRename uri text line char` -- clearAll, handleDidOpen, handlePrepareRename |> Async.RunSynchronously

Test list (testSequenced, testList "Rename"):

testList "Variable rename (RENAME-01)":
- "renames all variable occurrences": `let x = 1 in x + x` -- rename x to y at position (0, 14). Expect WorkspaceEdit with Changes containing 3 edits (definition + 2 usages), all with NewText = "y"
- "renames single occurrence": `let a = 42 in a` -- rename a to b. Expect 2 edits (definition + 1 usage)

testList "Function rename (RENAME-02)":
- "renames function and all calls": `let f = fun x -> x in f 1` -- rename f at call site. Expect edits for definition + call(s), all NewText = new name

testList "Prepare rename (RENAME-03)":
- "validates rename on variable": `let x = 1 in x` -- prepare at x usage. Expect Some with placeholder = "x"
- "rejects rename on number literal": `42` -- prepare at (0, 0). Expect None
- "accepts rename on let binding": prepare at (0, 4) on `let x = 1 in x`. Since cursor is on the variable name in Let node, should return Some with placeholder "x"

testList "Edge cases":
- "returns None for missing document": Expect None
- "returns None for parse error": `let x =` -- Expect None
- "rename edits have correct URI": verify all edits are in the correct URI key
  </action>
  <verify>
`dotnet build src/LangLSP.Tests/` compiles (after Task 2 updates fsproj).
  </verify>
  <done>
ReferencesTests.fs has tests for REF-01 (variable usages), REF-02 (function calls), REF-03 (includeDeclaration), shadowing, and edge cases. RenameTests.fs has tests for RENAME-01 (variable rename), RENAME-02 (function rename), RENAME-03 (prepareRename validation), and edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CodeActionsTests.fs, update fsproj, verify all tests pass</name>
  <files>src/LangLSP.Tests/CodeActionsTests.fs, src/LangLSP.Tests/LangLSP.Tests.fsproj</files>
  <action>
**CodeActionsTests.fs** -- module LangLSP.Tests.CodeActionsTests

Opens: Expecto, Ionide.LanguageServerProtocol.Types, LangLSP.Server.CodeActions, LangLSP.Server.Diagnostics, LangLSP.Server.DocumentSync

Helper functions:
- `makeDidOpenParams uri text`
- `makeCodeActionParams uri range diagnostics : CodeActionParams` -- TextDocument, Range, Context = { Diagnostics = diagnostics; Only = Some [| "quickfix" |]; TriggerKind = Some CodeActionTriggerKind.Invoked }, WorkDoneToken = None, PartialResultToken = None
- `setupAndGetActions uri text` -- clearAll, handleDidOpen, analyze to get diagnostics, then call handleCodeAction with those diagnostics and the range of the first diagnostic

Test list (testSequenced, testList "CodeActions"):

testList "Unused variable quickfix (ACTION-01)":
- "suggests prefix underscore for unused variable": `let x = 1 in 42` -- x is unused. Get diagnostics, expect an unused-variable warning. Call handleCodeAction with that diagnostic. Expect at least one CodeAction with kind "quickfix" and title containing "underscore" or "Prefix"
- "quickfix edits variable name": verify the returned CodeAction has Edit with Changes containing a TextEdit that replaces the variable name range with "_x"
- "no quickfix for used variable": `let x = 1 in x` -- x IS used. Diagnostics should have no unused-variable warning. Call handleCodeAction with empty diagnostics. Expect None (no actions)

testList "Type error code action (ACTION-02)":
- "shows expected type for type mismatch": Create code with a type error (e.g., `let x = 1 + true in x` or similar that produces a Type mismatch diagnostic). Get diagnostics, find the type error diagnostic. Call handleCodeAction with that diagnostic. Expect a CodeAction with title containing "Expected type" and kind "quickfix". Verify Edit is None (informational only, no auto-edit).
- "no action for type errors without parseable expected type": If the diagnostic message does not contain a parseable expected type, handleCodeAction should gracefully return no type-error actions (test with a synthetic diagnostic with unparseable message, or verify behavior with whatever FunLang produces)

testList "Unused variable detection":
- "detects unused let binding": `let x = 1 in 42` -- analyze returns warning with "Unused variable 'x'"
- "does not flag used variable": `let x = 1 in x` -- analyze returns no unused warnings
- "does not flag underscore-prefixed": `let _x = 1 in 42` -- analyze should NOT flag _x as unused
- "detects unused in nested let": `let a = 1 in let b = 2 in a` -- b is unused, a is used. Expect one unused warning for b
- "unused warnings have Warning severity": verify Severity = Some DiagnosticSeverity.Warning
- "unused warnings have Unnecessary tag": verify Tags contains DiagnosticTag.Unnecessary

testList "Edge cases":
- "no actions when no diagnostics": call handleCodeAction with empty diagnostics array. Expect None
- "handles non-funlang diagnostics": create a diagnostic with Source = Some "other". Expect None

**LangLSP.Tests.fsproj** -- Add all three test files to Compile list, before Program.fs:
```xml
<Compile Include="CompletionTests.fs" />
<Compile Include="ReferencesTests.fs" />
<Compile Include="RenameTests.fs" />
<Compile Include="CodeActionsTests.fs" />
<Compile Include="Program.fs" />
```

After updating fsproj, run all tests:
```bash
dotnet test src/LangLSP.Tests/ --verbosity normal
```

CRITICAL REGRESSION CHECK: The Diagnostics.fs change (adding unused variable warnings to `analyze`) may break existing tests. Specifically:
- Existing DiagnosticsTests.fs may call `analyze` on code that has unused variables and expect an empty diagnostic list or a specific count
- For example, `let x = 1 in x + 1` is fine (x is used), but `let x = 1 in 42` would now return a warning
- Run `dotnet test` FIRST to identify any failures
- If existing tests fail because they now receive unexpected Warning diagnostics:
  - Option A (preferred): Update test input code to not have unused variables (e.g., change `let x = 1 in 42` to `let x = 1 in x`)
  - Option B: Update test assertions to filter by Severity = Error when checking for error diagnostics only
  - Option C: Update expected diagnostic counts to include the new warnings
- Verify ALL existing 79 tests still pass alongside the ~20 new tests

If existing tests break, fix them in this task before marking complete.
  </action>
  <verify>
```bash
dotnet test src/LangLSP.Tests/ --verbosity normal
# ALL tests pass (new + existing)
# Expected: ~99+ tests (79 existing + ~20 new)
# Zero failures
```
  </verify>
  <done>
ReferencesTests.fs passes all reference tests (TEST-07). RenameTests.fs passes all rename tests (TEST-08). CodeActionsTests.fs passes all code action tests (TEST-09) including ACTION-02 type error informational action. Unused variable detection tests verify Warning severity and Unnecessary tag. No regressions in existing 79 tests.
  </done>
</task>

</tasks>

<verification>
```bash
dotnet test src/LangLSP.Tests/ --verbosity normal
# All tests pass with 0 failures
# New test count: ~22 (References ~8, Rename ~6, CodeActions ~8)
# Total tests: ~101+
# Existing 79 tests: all still passing
```
</verification>

<success_criteria>
- ReferencesTests covers REF-01 (variable), REF-02 (function), REF-03 (includeDeclaration), shadowing
- RenameTests covers RENAME-01 (variable rename), RENAME-02 (function rename), RENAME-03 (prepareRename)
- CodeActionsTests covers ACTION-01 (unused variable quickfix), ACTION-02 (type error informational action)
- CodeActionsTests verifies unused warnings have Warning severity and DiagnosticTag.Unnecessary
- All 3 test files follow project patterns (testSequenced, clearAll, Async.RunSynchronously)
- Zero test failures including all existing 79 tests (no regressions from Diagnostics.fs changes)
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features/04-03-SUMMARY.md`
</output>
