---
phase: 04-advanced-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/LangLSP.Server/References.fs
  - src/LangLSP.Server/Protocol.fs
  - src/LangLSP.Server/Server.fs
  - src/LangLSP.Server/LangLSP.Server.fsproj
autonomous: true

must_haves:
  truths:
    - "collectReferences returns all Var node spans matching a symbol name"
    - "collectReferencesForBinding returns only references to the specific binding at cursor position (shadowing-aware)"
    - "handleReferences returns Location[] for symbol at cursor with correct URI and ranges"
    - "includeDeclaration flag controls whether definition site is included in results"
  artifacts:
    - path: "src/LangLSP.Server/References.fs"
      provides: "Find References implementation"
      exports: ["collectReferences", "collectReferencesForBinding", "handleReferences"]
    - path: "src/LangLSP.Server/Protocol.fs"
      provides: "WorkspaceEdit helper functions"
      exports: ["createTextEdit", "createWorkspaceEdit"]
  key_links:
    - from: "src/LangLSP.Server/References.fs"
      to: "AstLookup.findNodeAtPosition"
      via: "import and call"
      pattern: "findNodeAtPosition"
    - from: "src/LangLSP.Server/References.fs"
      to: "Definition.findDefinitionForVar"
      via: "import and call for includeDeclaration"
      pattern: "findDefinitionForVar"
    - from: "src/LangLSP.Server/Server.fs"
      to: "References.handleReferences"
      via: "handler registration"
      pattern: "handleReferences"
---

<objective>
Implement the Find References feature (REF-01, REF-02, REF-03) that locates all usages of a symbol across the AST.

Purpose: Users need to find all places where a variable or function is used. This is the foundation for Rename Symbol (Plan 02) which reuses reference collection.
Output: References.fs module with scope-aware reference collection, Protocol.fs WorkspaceEdit helpers (needed by Rename), Server.fs with ReferencesProvider registered.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-advanced-features/04-RESEARCH.md
@src/LangLSP.Server/AstLookup.fs
@src/LangLSP.Server/Definition.fs
@src/LangLSP.Server/Protocol.fs
@src/LangLSP.Server/Server.fs
@src/LangLSP.Server/LangLSP.Server.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create References.fs with scope-aware reference collection</name>
  <files>src/LangLSP.Server/References.fs</files>
  <action>
Create `src/LangLSP.Server/References.fs` as module `LangLSP.Server.References`.

Open: Ionide.LanguageServerProtocol.Types, LangLSP.Server.AstLookup, LangLSP.Server.Definition, LangLSP.Server.DocumentSync, LangLSP.Server.Protocol, Ast

Implement three functions:

1. `collectReferences (varName: string) (ast: Expr) : Span list`
   - Traverse entire AST recursively collecting spans of all `Var(name, span)` nodes where `name = varName`
   - Must handle ALL Expr cases (follow same pattern as Definition.collectDefinitions traverse):
     - Let(_, value, body, _) -> traverse value, traverse body
     - LetRec(_, _, fnBody, inExpr, _) -> traverse fnBody, traverse inExpr
     - Lambda(_, body, _) / LambdaAnnot(_, _, body, _) -> traverse body
     - App(fn, arg, _) -> traverse fn, traverse arg
     - If(cond, then, else, _) -> traverse all three
     - Binary ops (Add, Subtract, etc.), Cons -> traverse both sides
     - Negate(e, _), Annot(e, _, _) -> traverse inner
     - Tuple(exprs, _), List(exprs, _) -> traverse all
     - Match(scrutinee, clauses, _) -> traverse scrutinee, traverse each clause body
     - LetPat(_, value, body, _) -> traverse value, traverse body
     - Leaf nodes (Number, Bool, String, EmptyList) -> skip
   - Use ResizeArray for collection, return Seq.toList at end

2. `collectReferencesForBinding (varName: string) (defSpan: Span) (ast: Expr) : Span list`
   - Scope-aware version: only collects Var references that refer to the SPECIFIC binding at defSpan
   - Strategy: use Definition.findDefinitionForVar for each found Var to check if its definition matches defSpan
   - For each Var(name, span) where name = varName:
     - Create a Position from span (Line = uint32 span.StartLine, Character = uint32 span.StartColumn)
     - Call findDefinitionForVar name ast position
     - If result matches defSpan (same StartLine and StartColumn), include this reference
   - This handles shadowing correctly: inner x references won't match outer x's defSpan

3. `handleReferences (p: ReferenceParams) : Async<Location[] option>`
   - Get document from DocumentSync.getDocument using p.TextDocument.Uri
   - Parse with LexBuffer.FromString + Parser.start Lexer.tokenize
   - Find node at position with findNodeAtPosition p.Position ast
   - If node is Var(name, varSpan):
     - Find definition: findDefinitionForVar name ast p.Position
     - Collect scoped references: collectReferencesForBinding name defSpan ast (using defSpan from definition lookup; if no definition found, fall back to collectReferences for all matches)
     - If p.Context.IncludeDeclaration is true AND definition was found, prepend defSpan to reference list
     - Convert all spans to Location[] using uri and spanToLspRange
   - If node is a binding site (Let, LetRec, Lambda, LambdaAnnot) -- use getIdentifierAtNode to get name, then:
     - Use the node's own span as the defSpan
     - Collect scoped references with collectReferencesForBinding
     - If IncludeDeclaration, include the binding span itself
   - Return Some locations or None on error
   - Wrap in try/with _ -> return None for parse errors

IMPORTANT: Follow the existing handler pattern (see handleDefinition, handleCompletion) for async structure and error handling.
  </action>
  <verify>
Add References.fs to fsproj (Task 2 handles this). Module compiles: `dotnet build src/LangLSP.Server/`
  </verify>
  <done>
References.fs exists with collectReferences, collectReferencesForBinding, handleReferences functions. All Expr cases handled in traversal. Shadowing resolved via findDefinitionForVar cross-check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Protocol helpers, update fsproj and Server.fs registration</name>
  <files>src/LangLSP.Server/Protocol.fs, src/LangLSP.Server/Server.fs, src/LangLSP.Server/LangLSP.Server.fsproj</files>
  <action>
**Protocol.fs** -- Add two helper functions after existing `diagnosticToLsp`:

```fsharp
/// Create TextEdit from span and new text
let createTextEdit (span: Span) (newText: string) : TextEdit =
    {
        Range = spanToLspRange span
        NewText = newText
    }

/// Create WorkspaceEdit for single-file changes
let createWorkspaceEdit (uri: string) (edits: TextEdit[]) : WorkspaceEdit =
    {
        Changes = Some (Map.ofList [ (uri, edits) ])
        DocumentChanges = None
        ChangeAnnotations = None
    }
```

**LangLSP.Server.fsproj** -- Add References.fs to the Compile list. It must appear AFTER Definition.fs (which it imports) and BEFORE Server.fs. Insert it after Completion.fs:

```xml
<Compile Include="Completion.fs" />
<Compile Include="References.fs" />
<Compile Include="Diagnostics.fs" />
```

NOTE: This fsproj ordering is temporary for Plan 01. Plan 02 will add Rename.fs and CodeActions.fs between References.fs and Diagnostics.fs, and will also need to reorder Diagnostics.fs to appear after References.fs (so Diagnostics can import References for unused variable detection).

**Server.fs** -- Add References handler:

1. Add `open LangLSP.Server.References` at top
2. Add to serverCapabilities:
   ```fsharp
   ReferencesProvider = Some (U2.C1 true)
   ```
3. Add to Handlers module:
   ```fsharp
   /// Handle textDocument/references request
   let textDocumentReferences (p: ReferenceParams) : Async<Location[] option> =
       References.handleReferences p
   ```

Do NOT add Rename or CodeAction capabilities yet -- those come in Plan 02.
  </action>
  <verify>
`dotnet build src/LangLSP.Server/` compiles without errors. Server.fs has ReferencesProvider in capabilities and textDocumentReferences handler.
  </verify>
  <done>
Protocol.fs has createTextEdit and createWorkspaceEdit helpers. References.fs is in fsproj compile order. Server.fs declares ReferencesProvider and routes to References.handleReferences.
  </done>
</task>

</tasks>

<verification>
```bash
dotnet build src/LangLSP.Server/
# Must compile with 0 errors
# References.fs, Protocol.fs updates, Server.fs updates all linked
```
</verification>

<success_criteria>
- References.fs module handles all AST node types in traversal
- Shadowing is handled via findDefinitionForVar cross-check (not naive string matching)
- includeDeclaration flag works for both Var nodes and binding sites
- Protocol.fs has createTextEdit and createWorkspaceEdit ready for Rename (Plan 02)
- Server.fs registers ReferencesProvider capability
- Project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features/04-01-SUMMARY.md`
</output>
