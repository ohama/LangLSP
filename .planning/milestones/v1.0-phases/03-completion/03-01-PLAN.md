---
phase: 03-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/LangLSP.Server/Completion.fs
  - src/LangLSP.Server/Server.fs
  - src/LangLSP.Server/LangLSP.Server.fsproj
autonomous: true

must_haves:
  truths:
    - "User invokes completion and sees keyword suggestions (let, if, match, fun, etc.)"
    - "User invokes completion and sees in-scope variable/function names"
    - "Completion items include type annotations in detail field"
    - "Only symbols defined before cursor position appear in completion list"
  artifacts:
    - path: "src/LangLSP.Server/Completion.fs"
      provides: "Completion module with handleCompletion, getKeywordCompletions, getSymbolCompletions"
      exports: ["handleCompletion", "getKeywordCompletions", "getSymbolCompletions", "funlangKeywords"]
    - path: "src/LangLSP.Server/Server.fs"
      provides: "Server capabilities with CompletionProvider"
      contains: "CompletionProvider"
  key_links:
    - from: "src/LangLSP.Server/Completion.fs"
      to: "Definition.collectDefinitions"
      via: "function call for scope tracking"
      pattern: "Definition\\.collectDefinitions"
    - from: "src/LangLSP.Server/Completion.fs"
      to: "Hover.findVarTypeInAst"
      via: "function call for type annotations"
      pattern: "Hover\\.findVarTypeInAst"
    - from: "src/LangLSP.Server/Server.fs"
      to: "Completion.handleCompletion"
      via: "handler registration"
      pattern: "Completion\\.handleCompletion"
---

<objective>
Implement the textDocument/completion handler for FunLang LSP.

Purpose: Enable autocomplete functionality in VS Code for FunLang keywords and in-scope symbols with type annotations.

Output: Completion.fs module with keyword completion, scope-based symbol completion, type annotations, and server integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-completion/03-RESEARCH.md

# Existing infrastructure to reuse
@src/LangLSP.Server/Definition.fs  # collectDefinitions for scope tracking
@src/LangLSP.Server/Hover.fs       # findVarTypeInAst for type annotations, keywordExplanations
@src/LangLSP.Server/Server.fs      # Server capabilities to extend
@src/LangLSP.Server/DocumentSync.fs # getDocument for text retrieval
@src/LangLSP.Server/Protocol.fs    # spanToLspRange for conversion
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Completion.fs module</name>
  <files>src/LangLSP.Server/Completion.fs, src/LangLSP.Server/LangLSP.Server.fsproj</files>
  <action>
Create src/LangLSP.Server/Completion.fs with these components:

1. **Module declaration and imports:**
   ```fsharp
   module LangLSP.Server.Completion

   open Ionide.LanguageServerProtocol.Types
   open LangLSP.Server.DocumentSync
   open LangLSP.Server.Definition
   open LangLSP.Server.Hover
   open Ast
   open Type
   ```

2. **Static keyword list (copy from Hover.keywordExplanations keys):**
   ```fsharp
   let funlangKeywords = [
       "let"; "in"; "if"; "then"; "else"; "match"; "with"
       "fun"; "rec"; "true"; "false"
   ]
   ```

3. **getKeywordCompletions function:**
   - Map each keyword to CompletionItem
   - Set Kind = CompletionItemKind.Keyword
   - Set Detail = Some "keyword"
   - Set InsertText = Some keyword
   - Set InsertTextFormat = Some InsertTextFormat.PlainText

4. **getSymbolCompletions function:**
   - Call Definition.collectDefinitions on ast
   - Filter to symbols defined BEFORE cursor position (scope filtering):
     ```fsharp
     |> List.filter (fun (_, span) ->
         span.StartLine < int pos.Line ||
         (span.StartLine = int pos.Line && span.StartColumn < int pos.Character))
     ```
   - Remove duplicates (keep last occurrence for shadowing): `|> List.rev |> List.distinctBy fst |> List.rev`
   - For each symbol, try to get type using Hover.findVarTypeInAst
   - Create CompletionItem with:
     - Label = symbol name
     - Kind = Some CompletionItemKind.Variable
     - Detail = type formatted as "name: type" or just name if no type
     - InsertText = Some name

5. **handleCompletion function (main entry point):**
   ```fsharp
   let handleCompletion (p: CompletionParams) : Async<CompletionList option> =
       async {
           let uri = p.TextDocument.Uri
           let pos = p.Position

           match getDocument uri with
           | None -> return None
           | Some text ->
               try
                   let lexbuf = FSharp.Text.Lexing.LexBuffer<char>.FromString(text)
                   let ast = Parser.start Lexer.tokenize lexbuf

                   let keywords = getKeywordCompletions()
                   let symbols = getSymbolCompletions ast pos

                   return Some {
                       IsIncomplete = false
                       Items = (keywords @ symbols) |> Array.ofList
                   }
               with _ ->
                   // On parse error, return only keywords
                   return Some {
                       IsIncomplete = false
                       Items = getKeywordCompletions() |> Array.ofList
                   }
       }
   ```

6. **Update LangLSP.Server.fsproj:**
   Add Completion.fs AFTER Definition.fs and BEFORE Server.fs in the compile item group:
   ```xml
   <Compile Include="Completion.fs" />
   ```
  </action>
  <verify>
dotnet build src/LangLSP.Server/LangLSP.Server.fsproj succeeds without errors
  </verify>
  <done>
Completion.fs exists with handleCompletion, getKeywordCompletions, getSymbolCompletions functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Register CompletionProvider in Server.fs</name>
  <files>src/LangLSP.Server/Server.fs</files>
  <action>
1. **Add import for Completion module:**
   ```fsharp
   open LangLSP.Server.Completion
   ```

2. **Update serverCapabilities to include CompletionProvider:**
   Add to the ServerCapabilities.Default with block:
   ```fsharp
   CompletionProvider = Some {
       ResolveProvider = Some false      // No lazy resolution
       TriggerCharacters = None          // No trigger chars for MVP
       AllCommitCharacters = None
       WorkDoneProgress = None
   }
   ```

3. **Add handler in Handlers module:**
   ```fsharp
   /// Handle textDocument/completion request
   /// Returns completion items for keywords and in-scope symbols
   let textDocumentCompletion (p: CompletionParams) : Async<CompletionList option> =
       Completion.handleCompletion p
   ```
  </action>
  <verify>
dotnet build src/LangLSP.Server/LangLSP.Server.fsproj succeeds
grep -q "CompletionProvider" src/LangLSP.Server/Server.fs
  </verify>
  <done>
Server.fs declares CompletionProvider capability and textDocumentCompletion handler
  </done>
</task>

</tasks>

<verification>
1. dotnet build src/LangLSP.Server/ succeeds
2. Completion.fs exports handleCompletion, getKeywordCompletions, getSymbolCompletions
3. Server.fs includes CompletionProvider in capabilities
4. No regressions in existing tests: dotnet test src/LangLSP.Tests/
</verification>

<success_criteria>
- Completion module compiles without errors
- CompletionProvider capability registered in server
- handleCompletion returns keyword and symbol completions
- Existing 61 tests continue passing
</success_criteria>

<output>
After completion, create `.planning/phases/03-completion/03-01-SUMMARY.md`
</output>
