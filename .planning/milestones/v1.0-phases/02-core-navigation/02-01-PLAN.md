---
phase: 02-core-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/LangLSP.Server/AstLookup.fs
  - src/LangLSP.Server/LangLSP.Server.fsproj
  - src/LangLSP.Tests/AstLookupTests.fs
  - src/LangLSP.Tests/LangLSP.Tests.fsproj
autonomous: true

must_haves:
  truths:
    - "Given an LSP Position (0-based), the system finds the innermost AST node containing that position"
    - "Position lookup handles all FunLang Expr variants (30+)"
    - "Position lookup correctly converts between LSP 0-based and FunLang 1-based coordinates"
  artifacts:
    - path: "src/LangLSP.Server/AstLookup.fs"
      provides: "Position-based AST traversal"
      exports: ["findNodeAtPosition", "findIdentifierAtPosition"]
    - path: "src/LangLSP.Tests/AstLookupTests.fs"
      provides: "Unit tests for AST lookup"
      min_lines: 60
  key_links:
    - from: "src/LangLSP.Server/AstLookup.fs"
      to: "Ast module"
      via: "uses Ast.Expr, Ast.spanOf"
      pattern: "open Ast|spanOf"
---

<objective>
Implement shared AST position lookup module that converts LSP positions to AST nodes.

Purpose: Both Hover and Go to Definition need to find the AST node at cursor position. This shared module provides that foundation, handling the 1-based vs 0-based position conversion pitfall identified in research.

Output: AstLookup.fs module with `findNodeAtPosition` function and comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-navigation/02-RESEARCH.md

# Phase 1 provides Protocol module with spanToLspRange
@src/LangLSP.Server/Protocol.fs

# FunLang AST structure with Span and spanOf helper
@LangTutorial/FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AstLookup.fs module</name>
  <files>
    src/LangLSP.Server/AstLookup.fs
    src/LangLSP.Server/LangLSP.Server.fsproj
  </files>
  <action>
Create `src/LangLSP.Server/AstLookup.fs` with:

1. **Module header:**
```fsharp
module LangLSP.Server.AstLookup

open Ast
open Ionide.LanguageServerProtocol.Types
```

2. **Position containment check:**
```fsharp
/// Check if LSP Position (0-based) is within FunLang Span (1-based)
let positionInSpan (lspPos: Position) (span: Span) : bool =
    // Convert LSP 0-based to FunLang 1-based
    let line = int lspPos.Line + 1
    let col = int lspPos.Character + 1
    // Check containment
    ...
```

3. **Recursive AST traversal:**
- `findNodeAtPosition` - returns innermost Expr containing position
- Handle ALL Expr variants (Number, Add, Subtract, Multiply, Divide, Negate, Var, Let, Bool, If, String, Equal, NotEqual, LessThan, GreaterThan, LessEqual, GreaterEqual, And, Or, Lambda, App, LetRec, Tuple, LetPat, EmptyList, List, Cons, Match, Annot, LambdaAnnot)
- Use `spanOf` helper from Ast module to get span from any Expr
- Return Option<Expr> - Some for found node, None for position outside AST

4. **Helper for identifier extraction:**
```fsharp
/// Extract identifier name if the node is a Var or binding site
let getIdentifierAtNode (expr: Expr) : string option =
    match expr with
    | Var(name, _) -> Some name
    | Let(name, _, _, _) -> Some name
    | Lambda(param, _, _) -> Some param
    | LetRec(name, param, _, _, _) -> Some name  // Could also return param
    | _ -> None
```

5. **Add to .fsproj** - Insert AstLookup.fs BEFORE Hover.fs/Definition.fs (which will be added later), AFTER Protocol.fs in compile order.

IMPORTANT: Position conversion must convert 0-based LSP to 1-based FunLang (add 1 to both line and character) before comparing with Span.
  </action>
  <verify>
    dotnet build src/LangLSP.Server/LangLSP.Server.fsproj
  </verify>
  <done>
    - AstLookup.fs compiles without errors
    - Module exports findNodeAtPosition and getIdentifierAtNode
    - Position conversion adds 1 to LSP line/character before comparison
  </done>
</task>

<task type="auto">
  <name>Task 2: Add AstLookup unit tests</name>
  <files>
    src/LangLSP.Tests/AstLookupTests.fs
    src/LangLSP.Tests/LangLSP.Tests.fsproj
  </files>
  <action>
Create `src/LangLSP.Tests/AstLookupTests.fs` with Expecto tests:

1. **Test setup helper:**
```fsharp
let parse code =
    let lexbuf = FSharp.Text.Lexing.LexBuffer<char>.FromString(code)
    Parser.start Lexer.tokenize lexbuf

let makePos line char = { Line = uint32 line; Character = uint32 char }
```

2. **Core test cases:**

| Test Name | Code | Position | Expected |
|-----------|------|----------|----------|
| "finds variable at position" | "let x = 42 in x" | (0, 14) | Var "x" |
| "finds number literal" | "let x = 42 in x" | (0, 8) | Number 42 |
| "finds let binding" | "let x = 42 in x" | (0, 4) | Let node |
| "finds function parameter" | "fun x -> x + 1" | (0, 4) | Lambda node |
| "returns None for position outside code" | "42" | (5, 0) | None |
| "finds nested expression" | "let x = 1 + 2 in x" | (0, 12) | Number 2 |
| "finds innermost node in nested let" | "let x = let y = 1 in y in x" | (0, 16) | Number 1 |

3. **getIdentifierAtNode tests:**
- "extracts Var name"
- "extracts Let binding name"
- "extracts Lambda param name"
- "returns None for Number"

4. **Add test file to .fsproj** in Compile items.

5. **Run tests:**
```bash
dotnet test src/LangLSP.Tests
```
  </action>
  <verify>
    dotnet test src/LangLSP.Tests --filter "AstLookup"
  </verify>
  <done>
    - All AstLookup tests pass
    - Test coverage includes: Var, Number, Let, Lambda, nested expressions, out-of-bounds
    - getIdentifierAtNode tests pass
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` succeeds
2. `dotnet test src/LangLSP.Tests --filter "AstLookup"` passes all tests
3. Module exports are accessible from other modules (verify with `open LangLSP.Server.AstLookup` in a test)
</verification>

<success_criteria>
- AstLookup.fs exists with findNodeAtPosition handling all 30+ Expr variants
- Position conversion correctly maps 0-based LSP to 1-based FunLang
- Unit tests pass for variable lookup, nested expressions, and edge cases
- Module is ready to be used by Hover and Definition implementations
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-navigation/02-01-SUMMARY.md`
</output>
