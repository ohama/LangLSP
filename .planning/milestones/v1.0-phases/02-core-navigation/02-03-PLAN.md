---
phase: 02-core-navigation
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/LangLSP.Server/Definition.fs
  - src/LangLSP.Server/Server.fs
  - src/LangLSP.Server/LangLSP.Server.fsproj
  - src/LangLSP.Tests/DefinitionTests.fs
  - src/LangLSP.Tests/LangLSP.Tests.fsproj
autonomous: true

must_haves:
  truths:
    - "User clicks variable and 'Go to Definition' jumps to where variable was bound"
    - "User clicks function call and jumps to function definition in same file"
    - "Definition lookup handles shadowed variables correctly (finds innermost binding)"
  artifacts:
    - path: "src/LangLSP.Server/Definition.fs"
      provides: "Definition request handler and symbol table"
      exports: ["handleDefinition", "collectDefinitions", "DefinitionMap"]
    - path: "src/LangLSP.Tests/DefinitionTests.fs"
      provides: "Definition unit tests"
      min_lines: 80
  key_links:
    - from: "src/LangLSP.Server/Definition.fs"
      to: "AstLookup.fs"
      via: "findNodeAtPosition for cursor location"
      pattern: "AstLookup\\.findNodeAtPosition"
    - from: "src/LangLSP.Server/Definition.fs"
      to: "Protocol.fs"
      via: "spanToLspRange for Location conversion"
      pattern: "spanToLspRange"
    - from: "src/LangLSP.Server/Server.fs"
      to: "Definition.fs"
      via: "capability registration"
      pattern: "DefinitionProvider|handleDefinition"
---

<objective>
Implement LSP textDocument/definition handler for Go to Definition navigation.

Purpose: Users clicking on a variable reference jump to where it was bound (GOTO-01). Clicking on a function call jumps to the function definition (GOTO-02). All navigation works within the same file (GOTO-03 - multi-file is out of scope per PROJECT.md).

Output: Definition.fs module with symbol table construction and definition lookup, plus comprehensive tests. Server.fs updated with definition capability.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-navigation/02-RESEARCH.md

# 02-01 provides AstLookup module (read SUMMARY when available)
# Document storage
@src/LangLSP.Server/DocumentSync.fs

# Protocol conversion utilities
@src/LangLSP.Server/Protocol.fs

# FunLang AST with Let, Lambda, LetRec, Match patterns
@LangTutorial/FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Definition.fs module with symbol table</name>
  <files>
    src/LangLSP.Server/Definition.fs
    src/LangLSP.Server/LangLSP.Server.fsproj
  </files>
  <action>
Create `src/LangLSP.Server/Definition.fs` with:

1. **Module header:**
```fsharp
module LangLSP.Server.Definition

open System.Collections.Generic
open Ionide.LanguageServerProtocol.Types
open LangLSP.Server.AstLookup
open LangLSP.Server.DocumentSync
open LangLSP.Server.Protocol
open Ast
```

2. **Definition map type:**
```fsharp
/// Maps (scope_path, variable_name) to definition Span
/// scope_path is a list of binding names from root to current scope
/// This handles shadowed variables by using scope-aware keys
type ScopeKey = string list * string
type DefinitionMap = Dictionary<ScopeKey, Span>
```

3. **Simpler approach - collect all definitions with their spans:**
```fsharp
/// Collect all variable/function definitions while traversing AST
/// Returns list of (name, span) pairs for all binding sites
let collectDefinitions (ast: Expr) : (string * Span) list =
    let defs = ResizeArray<string * Span>()

    let rec traverse expr =
        match expr with
        | Let(name, value, body, span) ->
            // Register let binding (span points to the let expression)
            // Better: create span just for the name
            defs.Add(name, span)
            traverse value
            traverse body

        | LetRec(name, param, fnBody, inExpr, span) ->
            // Register recursive function
            defs.Add(name, span)
            // param is also a binding site
            defs.Add(param, span)
            traverse fnBody
            traverse inExpr

        | Lambda(param, body, span) ->
            // Register lambda parameter
            defs.Add(param, span)
            traverse body

        | LetPat(pattern, value, body, span) ->
            // Collect bindings from pattern
            collectPatternBindings pattern
            traverse value
            traverse body

        | Match(scrutinee, clauses, _) ->
            traverse scrutinee
            for (pattern, clauseBody) in clauses do
                collectPatternBindings pattern
                traverse clauseBody

        | App(fn, arg, _) ->
            traverse fn
            traverse arg

        | If(cond, thenExpr, elseExpr, _) ->
            traverse cond
            traverse thenExpr
            traverse elseExpr

        | Add(l, r, _) | Subtract(l, r, _) | Multiply(l, r, _) | Divide(l, r, _)
        | Equal(l, r, _) | NotEqual(l, r, _) | LessThan(l, r, _) | GreaterThan(l, r, _)
        | LessEqual(l, r, _) | GreaterEqual(l, r, _) | And(l, r, _) | Or(l, r, _)
        | Cons(l, r, _) ->
            traverse l
            traverse r

        | Negate(e, _) | Annot(e, _, _) ->
            traverse e

        | LambdaAnnot(param, _, body, span) ->
            defs.Add(param, span)
            traverse body

        | Tuple(exprs, _) | List(exprs, _) ->
            exprs |> List.iter traverse

        | Number _ | Bool _ | String _ | Var _ | EmptyList _ -> ()

    and collectPatternBindings pattern =
        match pattern with
        | VarPat(name, span) -> defs.Add(name, span)
        | TuplePat(pats, _) -> pats |> List.iter collectPatternBindings
        | ConsPat(head, tail, _) ->
            collectPatternBindings head
            collectPatternBindings tail
        | WildcardPat _ | EmptyListPat _ | ConstPat _ -> ()

    traverse ast
    defs |> Seq.toList
```

4. **Find definition for variable at position:**
```fsharp
/// Find definition span for a variable reference
/// Walks outward from usage to find the closest binding
let findDefinitionForVar (varName: string) (ast: Expr) (usagePos: Position) : Span option =
    // Simple approach: find all definitions of varName, return the one
    // whose span starts before usagePos and is closest
    let defs = collectDefinitions ast
                |> List.filter (fun (name, _) -> name = varName)

    // For shadowing: need the definition that is in scope at usagePos
    // Simplest heuristic: return the definition that appears last before usage
    let usageLine = int usagePos.Line + 1
    let usageCol = int usagePos.Character + 1

    defs
    |> List.filter (fun (_, span) ->
        span.StartLine < usageLine ||
        (span.StartLine = usageLine && span.StartColumn <= usageCol))
    |> List.sortByDescending (fun (_, span) -> span.StartLine, span.StartColumn)
    |> List.tryHead
    |> Option.map snd
```

5. **Main handler:**
```fsharp
/// Handle textDocument/definition request
let handleDefinition (p: DefinitionParams) : Async<GotoResult option> =
    async {
        let uri = p.TextDocument.Uri
        let pos = p.Position

        match getDocument uri with
        | None -> return None
        | Some text ->
            try
                let lexbuf = FSharp.Text.Lexing.LexBuffer<char>.FromString(text)
                let ast = Parser.start Lexer.tokenize lexbuf

                match findNodeAtPosition pos ast with
                | None -> return None
                | Some node ->
                    match node with
                    | Var(name, _) ->
                        // Find where this variable was defined
                        match findDefinitionForVar name ast pos with
                        | None -> return None
                        | Some defSpan ->
                            let location : Location = {
                                Uri = uri
                                Range = spanToLspRange defSpan
                            }
                            return Some (GotoResult.Single location)
                    | _ ->
                        // Not a variable reference
                        return None
            with _ ->
                return None
    }
```

6. **Add to .fsproj** after AstLookup.fs (can be same wave as Hover.fs - no dependencies between them).

IMPORTANT:
- For shadowed variables like `let x = 1 in let x = 2 in x`, find the CLOSEST definition
- Lambda parameters are binding sites
- Match clause patterns introduce bindings
- Return GotoResult.Single for single-file projects (multi-file would use GotoResult.Multiple)
  </action>
  <verify>
    dotnet build src/LangLSP.Server/LangLSP.Server.fsproj
  </verify>
  <done>
    - Definition.fs compiles without errors
    - handleDefinition function handles Var references
    - collectDefinitions handles Let, LetRec, Lambda, LetPat, Match patterns
    - Shadowing handled by finding closest preceding definition
  </done>
</task>

<task type="auto">
  <name>Task 2: Register definition capability in Server.fs</name>
  <files>
    src/LangLSP.Server/Server.fs
  </files>
  <action>
Update `src/LangLSP.Server/Server.fs`:

1. **Add import:**
```fsharp
open LangLSP.Server.Definition
```

2. **Update serverCapabilities:**
```fsharp
let serverCapabilities : ServerCapabilities =
    { ServerCapabilities.Default with
        TextDocumentSync =
            Some (U2.C1 {
                TextDocumentSyncOptions.Default with
                    OpenClose = Some true
                    Change = Some TextDocumentSyncKind.Incremental
                    Save = Some (U2.C2 { IncludeText = Some false })
            })
        HoverProvider = Some (U2.C1 true)
        // ADD THIS:
        DefinitionProvider = Some (U2.C1 true)
    }
```

3. **Add definition handler to Handlers module:**
```fsharp
module Handlers =
    // ... existing handlers ...

    /// Handle textDocument/definition request
    let textDocumentDefinition (p: DefinitionParams) : Async<GotoResult option> =
        Definition.handleDefinition p
```

Note: Server.fs may already have HoverProvider from 02-02. If running in parallel, both plans add their respective capabilities. The merge is straightforward since they're different fields.
  </action>
  <verify>
    dotnet build src/LangLSP.Server/LangLSP.Server.fsproj
  </verify>
  <done>
    - Server.fs includes DefinitionProvider = Some (U2.C1 true)
    - Handlers.textDocumentDefinition function exists
    - No compilation errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Definition unit tests</name>
  <files>
    src/LangLSP.Tests/DefinitionTests.fs
    src/LangLSP.Tests/LangLSP.Tests.fsproj
  </files>
  <action>
Create `src/LangLSP.Tests/DefinitionTests.fs` with Expecto tests:

1. **Test setup:**
```fsharp
module LangLSP.Tests.DefinitionTests

open Expecto
open Ionide.LanguageServerProtocol.Types
open LangLSP.Server.Definition
open LangLSP.Server.DocumentSync

let makeDefinitionParams uri line char : DefinitionParams =
    {
        TextDocument = { Uri = uri }
        Position = { Line = uint32 line; Character = uint32 char }
        WorkDoneToken = None
        PartialResultToken = None
    }

let makeDidOpenParams uri text : DidOpenTextDocumentParams =
    {
        TextDocument = {
            Uri = uri
            LanguageId = "funlang"
            Version = 1
            Text = text
        }
    }

let setupAndDefinition uri text line char =
    clearAll()
    handleDidOpen (makeDidOpenParams uri text)
    handleDefinition (makeDefinitionParams uri line char) |> Async.RunSynchronously
```

2. **Variable definition tests (GOTO-01):**
```fsharp
testList "Variable definition" [
    testCase "finds let binding definition" <| fun _ ->
        // "let x = 42 in x"
        //              ^ position (0, 14) - the 'x' usage
        let result = setupAndDefinition "file:///test.fun" "let x = 42 in x" 0 14
        Expect.isSome result "Should find definition"
        match result.Value with
        | GotoResult.Single loc ->
            // Definition is at the 'let' expression
            Expect.equal loc.Uri "file:///test.fun" "Same file"
            Expect.equal (int loc.Range.Start.Line) 0 "Line 0"
        | _ -> failtest "Expected single location"

    testCase "finds lambda parameter definition" <| fun _ ->
        // "fun x -> x + 1"
        //          ^ position (0, 9) - the 'x' usage in body
        let result = setupAndDefinition "file:///test.fun" "fun x -> x + 1" 0 9
        Expect.isSome result "Should find definition"
        match result.Value with
        | GotoResult.Single loc ->
            Expect.equal (int loc.Range.Start.Line) 0 "Line 0"
        | _ -> failtest "Expected single location"

    testCase "finds nested let binding" <| fun _ ->
        // "let x = 1 in let y = x in y"
        //                           ^ position - y usage
        let result = setupAndDefinition "file:///test.fun" "let x = 1 in let y = x in y" 0 26
        Expect.isSome result "Should find y definition"
]
```

3. **Function definition tests (GOTO-02):**
```fsharp
testList "Function definition" [
    testCase "finds function definition at call site" <| fun _ ->
        // "let f = fun x -> x + 1 in f 5"
        //                           ^ f call at position (0, 26)
        let result = setupAndDefinition "file:///test.fun" "let f = fun x -> x + 1 in f 5" 0 26
        Expect.isSome result "Should find function definition"

    testCase "finds recursive function definition" <| fun _ ->
        // "let rec fact n = if n = 0 then 1 else n * fact (n - 1) in fact 5"
        //                                             ^ recursive call
        let code = "let rec fact n = if n = 0 then 1 else n * fact (n - 1) in fact 5"
        let result = setupAndDefinition "file:///test.fun" code 0 43
        Expect.isSome result "Should find recursive function definition"
]
```

4. **Shadowing tests (critical for correctness):**
```fsharp
testList "Variable shadowing" [
    testCase "finds inner binding for shadowed variable" <| fun _ ->
        // "let x = 1 in let x = 2 in x"
        //                           ^ should find inner x (position 0, 26)
        let result = setupAndDefinition "file:///test.fun" "let x = 1 in let x = 2 in x" 0 26
        Expect.isSome result "Should find definition"
        match result.Value with
        | GotoResult.Single loc ->
            // Inner let starts around column 13
            Expect.isGreaterThan (int loc.Range.Start.Character) 10 "Should be inner definition"
        | _ -> failtest "Expected single location"

    testCase "finds outer binding for outer usage" <| fun _ ->
        // "let x = 1 in x + (let x = 2 in x)"
        //              ^ outer x usage
        let result = setupAndDefinition "file:///test.fun" "let x = 1 in x + (let x = 2 in x)" 0 13
        Expect.isSome result "Should find outer definition"
        match result.Value with
        | GotoResult.Single loc ->
            // Outer let starts at column 0
            Expect.equal (int loc.Range.Start.Character) 0 "Should be outer definition"
        | _ -> failtest "Expected single location"
]
```

5. **Edge case tests:**
```fsharp
testList "Edge cases" [
    testCase "returns None for unbound variable" <| fun _ ->
        // If we somehow had an unbound variable (though parser/typechecker would catch it)
        let result = setupAndDefinition "file:///test.fun" "42" 0 0
        Expect.isNone result "Number has no definition"

    testCase "returns None outside code" <| fun _ ->
        let result = setupAndDefinition "file:///test.fun" "let x = 1 in x" 5 0
        Expect.isNone result "Position outside code"

    testCase "returns None for undocumented URI" <| fun _ ->
        clearAll()
        let result = handleDefinition (makeDefinitionParams "file:///unknown.fun" 0 0) |> Async.RunSynchronously
        Expect.isNone result "Unknown document"

    testCase "returns same-file URI" <| fun _ ->
        let result = setupAndDefinition "file:///test.fun" "let x = 42 in x" 0 14
        Expect.isSome result "Should find definition"
        match result.Value with
        | GotoResult.Single loc ->
            Expect.equal loc.Uri "file:///test.fun" "Definition in same file (GOTO-03)"
        | _ -> failtest "Expected single location"
]
```

6. **Add test file to .fsproj.**

7. **Run tests:**
```bash
dotnet test src/LangLSP.Tests --filter "Definition"
```
  </action>
  <verify>
    dotnet test src/LangLSP.Tests --filter "Definition"
  </verify>
  <done>
    - All Definition tests pass
    - Tests cover: let bindings, lambda params, recursive functions, shadowing, edge cases
    - Shadowing test verifies correct scope resolution
    - Same-file URI test verifies GOTO-03
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` succeeds
2. `dotnet test src/LangLSP.Tests --filter "Definition"` passes all tests
3. Server capabilities include DefinitionProvider
4. Shadowed variable test specifically verifies innermost binding is found
</verification>

<success_criteria>
- Go to Definition on variable jumps to let binding (GOTO-01)
- Go to Definition on function call jumps to function definition (GOTO-02)
- All definitions are in same file (GOTO-03 - single-file scope)
- Shadowed variables resolve to correct (innermost) binding
- All Definition unit tests pass (TEST-06)
- Definition capability registered in Server.fs
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-navigation/02-03-SUMMARY.md`
</output>
