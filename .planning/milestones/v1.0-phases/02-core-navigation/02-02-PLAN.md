---
phase: 02-core-navigation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/LangLSP.Server/Hover.fs
  - src/LangLSP.Server/Server.fs
  - src/LangLSP.Server/LangLSP.Server.fsproj
  - src/LangLSP.Tests/HoverTests.fs
  - src/LangLSP.Tests/LangLSP.Tests.fsproj
autonomous: true

must_haves:
  truths:
    - "User hovers over variable and sees its inferred type from Hindley-Milner type checker"
    - "User hovers over function name and sees function signature with parameter and return types"
    - "User hovers over keyword (let, if, match) and sees explanation in Korean"
  artifacts:
    - path: "src/LangLSP.Server/Hover.fs"
      provides: "Hover request handler"
      exports: ["handleHover", "keywordExplanations"]
    - path: "src/LangLSP.Tests/HoverTests.fs"
      provides: "Hover unit tests"
      min_lines: 80
  key_links:
    - from: "src/LangLSP.Server/Hover.fs"
      to: "AstLookup.fs"
      via: "findNodeAtPosition"
      pattern: "AstLookup\\.findNodeAtPosition"
    - from: "src/LangLSP.Server/Hover.fs"
      to: "TypeCheck module"
      via: "typecheck call for type inference"
      pattern: "TypeCheck\\."
    - from: "src/LangLSP.Server/Server.fs"
      to: "Hover.fs"
      via: "capability registration and handler wiring"
      pattern: "HoverProvider|handleHover"
---

<objective>
Implement LSP textDocument/hover handler showing type information and keyword explanations.

Purpose: Users hovering over variables see inferred types (HOVER-01), functions show signatures (HOVER-02), and FunLang keywords show Korean explanations (HOVER-03). This is a core IDE feature that leverages the existing type checker.

Output: Hover.fs module with request handler, Korean keyword explanations, and comprehensive tests. Server.fs updated with hover capability.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-navigation/02-RESEARCH.md

# 02-01 provides AstLookup module (read SUMMARY when available)
# Type formatting function
@LangTutorial/FunLang/Type.fs

# Existing document storage
@src/LangLSP.Server/DocumentSync.fs

# Protocol conversion utilities
@src/LangLSP.Server/Protocol.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Hover.fs module</name>
  <files>
    src/LangLSP.Server/Hover.fs
    src/LangLSP.Server/LangLSP.Server.fsproj
  </files>
  <action>
Create `src/LangLSP.Server/Hover.fs` with:

1. **Module header:**
```fsharp
module LangLSP.Server.Hover

open Ionide.LanguageServerProtocol.Types
open LangLSP.Server.AstLookup
open LangLSP.Server.DocumentSync
open LangLSP.Server.Protocol
open Ast
open Type
```

2. **Korean keyword explanations map (HOVER-03):**
```fsharp
/// Korean explanations for FunLang keywords
let keywordExplanations = Map.ofList [
    ("let", "변수 또는 함수를 정의합니다.\n예: `let x = 5`")
    ("in", "let 바인딩의 범위를 지정합니다.\n예: `let x = 1 in x + 2`")
    ("if", "조건 분기를 수행합니다.\n예: `if x > 0 then 1 else -1`")
    ("then", "if의 참 분기를 시작합니다.")
    ("else", "if의 거짓 분기를 시작합니다.")
    ("match", "패턴 매칭을 시작합니다.\n예: `match xs with | [] -> 0 | h::t -> h`")
    ("with", "match의 패턴 절을 시작합니다.")
    ("fun", "익명 함수를 정의합니다.\n예: `fun x -> x + 1`")
    ("rec", "재귀 함수를 정의합니다.\n예: `let rec sum n = if n = 0 then 0 else n + sum (n-1)`")
    ("true", "불리언 참 값입니다.")
    ("false", "불리언 거짓 값입니다.")
]
```

3. **Keyword detection helper:**
```fsharp
/// Extract word at position from source text
let getWordAtPosition (text: string) (pos: Position) : string option =
    let lines = text.Split('\n')
    let lineIdx = int pos.Line
    if lineIdx >= lines.Length then None
    else
        let line = lines.[lineIdx]
        let col = int pos.Character
        if col >= line.Length then None
        else
            // Find word boundaries (alphanumeric chars)
            let isWordChar c = System.Char.IsLetterOrDigit(c) || c = '_'
            let mutable startCol = col
            while startCol > 0 && isWordChar line.[startCol - 1] do
                startCol <- startCol - 1
            let mutable endCol = col
            while endCol < line.Length && isWordChar line.[endCol] do
                endCol <- endCol + 1
            if startCol = endCol then None
            else Some (line.Substring(startCol, endCol - startCol))

/// Create hover for keyword
let createKeywordHover (keyword: string) (pos: Position) : Hover option =
    keywordExplanations
    |> Map.tryFind keyword
    |> Option.map (fun explanation ->
        {
            Contents = U2.C2 {
                Kind = MarkupKind.Markdown
                Value = sprintf "**%s** (키워드)\n\n%s" keyword explanation
            }
            Range = None  // Could calculate exact keyword range if needed
        })
```

4. **Type hover creation (HOVER-01, HOVER-02):**
```fsharp
/// Create hover with type information
let createTypeHover (ty: Type.Type) (span: Span) : Hover =
    let typeStr = Type.formatTypeNormalized ty
    {
        Contents = U2.C2 {
            Kind = MarkupKind.Markdown
            Value = sprintf "```funlang\n%s\n```" typeStr
        }
        Range = Some (spanToLspRange span)
    }
```

5. **Main handler (all cases):**
```fsharp
/// Handle textDocument/hover request
let handleHover (p: HoverParams) : Async<Hover option> =
    async {
        let uri = p.TextDocument.Uri
        let pos = p.Position

        match getDocument uri with
        | None -> return None
        | Some text ->
            // Check for keyword hover first
            match getWordAtPosition text pos with
            | Some word when keywordExplanations.ContainsKey word ->
                return createKeywordHover word pos
            | _ ->
                // Try AST-based hover for types
                try
                    let lexbuf = FSharp.Text.Lexing.LexBuffer<char>.FromString(text)
                    let ast = Parser.start Lexer.tokenize lexbuf
                    match findNodeAtPosition pos ast with
                    | None -> return None
                    | Some node ->
                        // Type check the expression to get its type
                        match TypeCheck.typecheck ast with
                        | Error _ -> return None
                        | Ok _ ->
                            // Need to get type of specific node
                            // For now, type check the node directly
                            match TypeCheck.typecheck node with
                            | Error _ -> return None
                            | Ok ty ->
                                return Some (createTypeHover ty (spanOf node))
                with _ ->
                    return None
    }
```

6. **Add to .fsproj** after AstLookup.fs in compile order.

IMPORTANT:
- Keyword check happens BEFORE AST lookup (keywords aren't in AST)
- Use MarkupKind.Markdown for syntax highlighting in VS Code
- Use Type.formatTypeNormalized for clean type display ('a, 'b instead of TVar 1000)
  </action>
  <verify>
    dotnet build src/LangLSP.Server/LangLSP.Server.fsproj
  </verify>
  <done>
    - Hover.fs compiles without errors
    - handleHover function is exported
    - keywordExplanations map contains all FunLang keywords
    - Type hover uses formatTypeNormalized
  </done>
</task>

<task type="auto">
  <name>Task 2: Register hover capability in Server.fs</name>
  <files>
    src/LangLSP.Server/Server.fs
  </files>
  <action>
Update `src/LangLSP.Server/Server.fs`:

1. **Add import:**
```fsharp
open LangLSP.Server.Hover
```

2. **Update serverCapabilities to include hover:**
```fsharp
let serverCapabilities : ServerCapabilities =
    { ServerCapabilities.Default with
        TextDocumentSync =
            Some (U2.C1 {
                TextDocumentSyncOptions.Default with
                    OpenClose = Some true
                    Change = Some TextDocumentSyncKind.Incremental
                    Save = Some (U2.C2 { IncludeText = Some false })
            })
        // ADD THIS:
        HoverProvider = Some (U2.C1 true)
    }
```

3. **Add hover handler to Handlers module:**
```fsharp
module Handlers =
    // ... existing handlers ...

    /// Handle textDocument/hover request
    let textDocumentHover (p: HoverParams) : Async<Hover option> =
        Hover.handleHover p
```

The actual handler registration will happen in Program.fs (deferred to later phase when full message loop is implemented). For now, the handler is exposed via the Handlers module.
  </action>
  <verify>
    dotnet build src/LangLSP.Server/LangLSP.Server.fsproj
  </verify>
  <done>
    - Server.fs includes HoverProvider = Some (U2.C1 true) in capabilities
    - Handlers.textDocumentHover function exists
    - No compilation errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Hover unit tests</name>
  <files>
    src/LangLSP.Tests/HoverTests.fs
    src/LangLSP.Tests/LangLSP.Tests.fsproj
  </files>
  <action>
Create `src/LangLSP.Tests/HoverTests.fs` with Expecto tests:

1. **Test setup:**
```fsharp
module LangLSP.Tests.HoverTests

open Expecto
open Ionide.LanguageServerProtocol.Types
open LangLSP.Server.Hover
open LangLSP.Server.DocumentSync

let makeHoverParams uri line char : HoverParams =
    {
        TextDocument = { Uri = uri }
        Position = { Line = uint32 line; Character = uint32 char }
        WorkDoneToken = None
    }

let makeDidOpenParams uri text : DidOpenTextDocumentParams =
    {
        TextDocument = {
            Uri = uri
            LanguageId = "funlang"
            Version = 1
            Text = text
        }
    }

let setupAndHover uri text line char =
    clearAll()  // Clear document storage
    handleDidOpen (makeDidOpenParams uri text)
    handleHover (makeHoverParams uri line char) |> Async.RunSynchronously
```

2. **Keyword hover tests (HOVER-03):**
```fsharp
testList "Keyword hover" [
    testCase "hover over 'let' shows Korean explanation" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "let x = 42 in x" 0 0
        Expect.isSome hover "Should return hover"
        match hover.Value.Contents with
        | U2.C2 markup ->
            Expect.stringContains markup.Value "let" "Should mention keyword"
            Expect.stringContains markup.Value "변수" "Should have Korean explanation"
        | _ -> failtest "Expected MarkupContent"

    testCase "hover over 'if' shows Korean explanation" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "if true then 1 else 0" 0 0
        Expect.isSome hover "Should return hover"
        match hover.Value.Contents with
        | U2.C2 markup ->
            Expect.stringContains markup.Value "조건" "Should explain conditionals"
        | _ -> failtest "Expected MarkupContent"

    testCase "hover over 'fun' shows Korean explanation" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "fun x -> x" 0 0
        Expect.isSome hover "Should return hover"
]
```

3. **Type hover tests (HOVER-01, HOVER-02):**
```fsharp
testList "Type hover" [
    testCase "hover over variable shows inferred int type" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "let x = 42 in x" 0 14
        Expect.isSome hover "Should return hover for variable"
        match hover.Value.Contents with
        | U2.C2 markup ->
            Expect.stringContains markup.Value "int" "Should show int type"
        | _ -> failtest "Expected MarkupContent"

    testCase "hover over function shows signature" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "let f = fun x -> x + 1 in f" 0 26
        Expect.isSome hover "Should return hover for function"
        match hover.Value.Contents with
        | U2.C2 markup ->
            Expect.stringContains markup.Value "int -> int" "Should show function signature"
        | _ -> failtest "Expected MarkupContent"

    testCase "hover over polymorphic function shows generic type" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "let id = fun x -> x in id" 0 23
        Expect.isSome hover "Should return hover"
        match hover.Value.Contents with
        | U2.C2 markup ->
            Expect.stringContains markup.Value "'a" "Should show polymorphic type variable"
            Expect.stringContains markup.Value "->" "Should show arrow"
        | _ -> failtest "Expected MarkupContent"

    testCase "hover outside code returns None" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "42" 5 0
        Expect.isNone hover "Should return None for out-of-bounds"

    testCase "hover on undocumented location returns None" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "" 0 0
        Expect.isNone hover "Should return None for empty document"
]
```

4. **Edge case tests:**
```fsharp
testList "Edge cases" [
    testCase "hover on parse error returns None" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "let x =" 0 4
        Expect.isNone hover "Should return None on parse error"

    testCase "hover returns markdown format" <| fun _ ->
        let hover = setupAndHover "file:///test.fun" "let x = 42 in x" 0 14
        Expect.isSome hover "Should return hover"
        match hover.Value.Contents with
        | U2.C2 markup ->
            Expect.equal markup.Kind MarkupKind.Markdown "Should use Markdown kind"
        | _ -> failtest "Expected MarkupContent"
]
```

5. **Add test file to .fsproj.**

6. **Run all tests:**
```bash
dotnet test src/LangLSP.Tests
```
  </action>
  <verify>
    dotnet test src/LangLSP.Tests --filter "Hover"
  </verify>
  <done>
    - All Hover tests pass
    - Tests cover: keyword hover (let, if, fun), variable type, function signature, polymorphic types, edge cases
    - clearAll() is called before each test to avoid state pollution
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` succeeds
2. `dotnet test src/LangLSP.Tests --filter "Hover"` passes all tests
3. Server capabilities include HoverProvider
4. Korean keyword explanations work for: let, in, if, then, else, match, with, fun, rec, true, false
</verification>

<success_criteria>
- Hover over variable shows its inferred type (HOVER-01)
- Hover over function shows signature like "int -> int" (HOVER-02)
- Hover over keyword shows Korean explanation (HOVER-03)
- All Hover unit tests pass (TEST-04)
- Hover capability registered in Server.fs
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-navigation/02-02-SUMMARY.md`
</output>
