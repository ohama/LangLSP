---
phase: 02-core-navigation
plan: 05
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - docs/08-definition.md
autonomous: true

must_haves:
  truths:
    - "Tutorial explains how to implement Go to Definition with actual code examples"
    - "Tutorial covers symbol table construction for definition lookup"
    - "Tutorial is in Korean for target audience"
  artifacts:
    - path: "docs/08-definition.md"
      provides: "Go to Definition implementation tutorial"
      min_lines: 200
  key_links:
    - from: "docs/08-definition.md"
      to: "src/LangLSP.Server/Definition.fs"
      via: "code examples reference actual implementation"
      pattern: "Definition\\.fs|handleDefinition|collectDefinitions"
---

<objective>
Write Korean tutorial for implementing LSP textDocument/definition feature.

Purpose: LSP learners understand how Go to Definition works through step-by-step explanation with actual code from this project (TUT-08). The tutorial covers symbol table construction, scope resolution, and definition lookup.

Output: docs/08-definition.md with comprehensive Korean tutorial on Go to Definition implementation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-navigation/02-RESEARCH.md

# 02-03 SUMMARY has implementation details
# Actual implementation files:
@src/LangLSP.Server/Definition.fs
@src/LangLSP.Server/AstLookup.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Go to Definition tutorial in Korean</name>
  <files>
    docs/08-definition.md
  </files>
  <action>
Create `docs/08-definition.md` with the following structure (all content in Korean):

1. **Title and Introduction:**
```markdown
# 08. Go to Definition 구현하기

변수나 함수를 클릭하고 "Go to Definition"을 실행하면 해당 심볼이 정의된 위치로 이동합니다. 이 기능은 코드 네비게이션의 핵심으로, 대규모 코드베이스에서 특히 유용합니다.

이 튜토리얼에서는 FunLang LSP에 Go to Definition 기능을 구현하는 방법을 배웁니다.
```

2. **LSP Protocol Explanation:**
- `textDocument/definition` 요청 구조
- DefinitionParams (TextDocumentIdentifier + Position)
- 응답 형식: Location | Location[] | LocationLink[]
- Location 구조 (URI + Range)

3. **Symbol Table Concept:**
```markdown
## 심볼 테이블

Go to Definition을 구현하려면 "어떤 변수가 어디서 정의되었는지"를 알아야 합니다. 이를 위해 심볼 테이블(Symbol Table)을 구축합니다.

심볼 테이블은 변수/함수 이름을 정의 위치에 매핑합니다:

| 이름 | 정의 위치 |
|------|----------|
| `x` | 1:4 (let x = ...) |
| `f` | 3:4 (let f = fun ...) |
```

4. **Binding Sites in FunLang:**
```markdown
## FunLang의 바인딩 위치

FunLang에서 변수가 정의되는 곳:

1. **let 바인딩**: `let x = 42 in ...`
2. **let rec 바인딩**: `let rec fact n = ...`
3. **람다 파라미터**: `fun x -> ...`
4. **패턴 매칭**: `match xs with | h::t -> ...`

각 바인딩 형태에서 정의 위치를 수집해야 합니다.
```

5. **Implementation Strategy:**

Section A: 정의 수집 (Definition.fs)
```markdown
### 정의 수집

AST를 순회하며 모든 바인딩을 수집합니다:

```fsharp
let collectDefinitions (ast: Expr) : (string * Span) list =
    let defs = ResizeArray<string * Span>()

    let rec traverse expr =
        match expr with
        | Let(name, value, body, span) ->
            defs.Add(name, span)
            traverse value
            traverse body
        | Lambda(param, body, span) ->
            defs.Add(param, span)
            traverse body
        // ... 모든 바인딩 형태 처리
```
```

Section B: 스코프 처리 (중요!)
```markdown
### 변수 섀도잉 처리

같은 이름의 변수가 여러 번 정의될 수 있습니다:

```funlang
let x = 1 in
  let x = 2 in
    x  (* 여기서 x는 어느 정의를 가리킬까요? *)
```

정답: 가장 가까운(내부) 정의인 `let x = 2`입니다.

구현에서는 사용 위치 이전에 정의된 것 중 가장 나중에 나온 것을 선택합니다.
```

Section C: 핸들러 구현 (Definition.fs)
```markdown
### 핸들러 구현

```fsharp
let handleDefinition (p: DefinitionParams) : Async<GotoResult option> =
    async {
        let uri = p.TextDocument.Uri
        let pos = p.Position

        match getDocument uri with
        | None -> return None
        | Some text ->
            // 1. 파싱
            let ast = Parser.start Lexer.tokenize lexbuf

            // 2. 커서 위치의 노드 찾기
            match findNodeAtPosition pos ast with
            | Some (Var(name, _)) ->
                // 3. 해당 변수의 정의 찾기
                match findDefinitionForVar name ast pos with
                | Some defSpan ->
                    return Some (GotoResult.Single {
                        Uri = uri
                        Range = spanToLspRange defSpan
                    })
                | None -> return None
            | _ -> return None
    }
```
```

6. **Integration with Server:**
- 서버 capabilities에 DefinitionProvider 등록
- 핸들러 연결

7. **Testing Strategy:**
```markdown
## 테스트

Go to Definition은 다음을 테스트해야 합니다:

1. **기본 정의** - `let x = 1 in x` → x 정의로 이동
2. **람다 파라미터** - `fun x -> x` → 파라미터 정의로 이동
3. **재귀 함수** - `let rec f n = ... f (n-1)` → f 정의로 이동
4. **섀도잉** - 내부 바인딩이 선택되는지 확인
5. **같은 파일** - URI가 동일한지 확인
```

8. **Common Pitfalls:**
```markdown
## 흔한 실수

1. **섀도잉 무시** - 항상 첫 번째 정의만 반환하면 안 됨
2. **패턴 바인딩 누락** - match 절의 패턴도 바인딩임
3. **람다 파라미터 누락** - `fun x -> ...`의 x도 바인딩
4. **let rec 파라미터** - `let rec f x = ...`에서 f와 x 모두 바인딩
```

9. **Single-File vs Multi-File:**
```markdown
## 싱글 파일 vs 멀티 파일

FunLang LSP는 싱글 파일만 지원합니다 (모듈 시스템 없음).

따라서:
- 항상 같은 URI 반환
- `GotoResult.Single` 사용 (배열 아님)

멀티 파일 지원 시:
- 모듈별 심볼 테이블 필요
- import/require 추적 필요
- `Location[]` 반환 가능 (여러 정의)
```

10. **Summary:**
```markdown
## 정리

Go to Definition 구현의 핵심은:
1. **바인딩 수집** - AST 순회로 모든 정의 위치 수집
2. **스코프 해결** - 섀도잉 시 가장 가까운 정의 선택
3. **위치 변환** - FunLang Span → LSP Location
4. **Var 노드만 처리** - 변수 참조에서만 동작
```

11. **Next Steps:**
```markdown
## 다음 단계

→ [09. Completion 구현하기](09-completion.md) (Phase 3)
```

**Writing Guidelines:**
- Use actual code from Definition.fs
- Explain the shadow variable problem thoroughly
- Include visual examples of FunLang code
- Target audience: LSP beginners
- Total length: 250-350 lines
  </action>
  <verify>
    cat docs/08-definition.md | wc -l
    # Verify file exists and has substantial content (> 200 lines)
  </verify>
  <done>
    - docs/08-definition.md exists with Korean content
    - Tutorial covers: symbol table, binding sites, shadowing, testing
    - Code examples reference actual implementation files
    - Minimum 200 lines of content
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify tutorial accuracy against implementation</name>
  <files>
    docs/08-definition.md
  </files>
  <action>
Cross-reference tutorial code examples with actual implementation:

1. **Check Definition.fs references:**
   - collectDefinitions function structure matches
   - handleDefinition flow matches actual implementation
   - All binding forms covered (Let, LetRec, Lambda, LetPat, Match patterns)

2. **Check AstLookup references:**
   - findNodeAtPosition usage matches

3. **Check Protocol.fs references:**
   - spanToLspRange is correctly documented

4. **Verify Korean terminology consistency:**
   - "정의" for definition
   - "바인딩" for binding
   - "스코프" for scope
   - "섀도잉" for shadowing
   - "심볼 테이블" for symbol table

If any discrepancies found, update the tutorial to match actual implementation.
  </action>
  <verify>
    # Manual verification - compare code snippets in tutorial with actual files
    grep -o "let.*=" docs/08-definition.md | head -5
  </verify>
  <done>
    - All code examples reflect actual implementation
    - Binding forms match what collectDefinitions handles
    - Korean terminology is consistent throughout
  </done>
</task>

</tasks>

<verification>
1. `docs/08-definition.md` exists
2. File contains > 200 lines of Korean content
3. Code examples reference real functions from Definition.fs
4. Variable shadowing handling is clearly explained
5. All FunLang binding forms are documented (let, let rec, lambda, pattern match)
</verification>

<success_criteria>
- Tutorial explains Go to Definition implementation with code examples (TUT-08)
- Korean language throughout
- Symbol table concept clearly explained
- Variable shadowing problem and solution documented
- All binding forms covered (let, let rec, lambda, patterns)
- Tutorial is actionable - reader could implement similar feature
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-navigation/02-05-SUMMARY.md`
</output>
