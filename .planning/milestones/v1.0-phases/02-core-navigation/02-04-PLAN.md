---
phase: 02-core-navigation
plan: 04
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - docs/06-hover.md
autonomous: true

must_haves:
  truths:
    - "Tutorial explains how to implement Hover with actual code examples from this project"
    - "Tutorial covers position mapping pitfalls (0-based vs 1-based)"
    - "Tutorial is in Korean for target audience"
  artifacts:
    - path: "docs/06-hover.md"
      provides: "Hover implementation tutorial"
      min_lines: 200
  key_links:
    - from: "docs/06-hover.md"
      to: "src/LangLSP.Server/Hover.fs"
      via: "code examples reference actual implementation"
      pattern: "Hover\\.fs|handleHover|keywordExplanations"
---

<objective>
Write Korean tutorial for implementing LSP textDocument/hover feature.

Purpose: LSP learners understand how hover works through step-by-step explanation with actual code from this project (TUT-06). The tutorial shows position lookup, type inference integration, and keyword explanations.

Output: docs/06-hover.md with comprehensive Korean tutorial on Hover implementation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-navigation/02-RESEARCH.md

# 02-02 SUMMARY has implementation details
# Actual implementation files:
@src/LangLSP.Server/Hover.fs
@src/LangLSP.Server/AstLookup.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Hover tutorial in Korean</name>
  <files>
    docs/06-hover.md
  </files>
  <action>
Create `docs/06-hover.md` with the following structure (all content in Korean):

1. **Title and Introduction:**
```markdown
# 06. Hover 구현하기

마우스 커서를 코드 위에 올리면 타입 정보나 설명이 팝업으로 표시됩니다. 이 기능은 IDE의 핵심 기능 중 하나로, 코드를 이해하는 데 큰 도움이 됩니다.

이 튜토리얼에서는 FunLang LSP에 Hover 기능을 구현하는 방법을 배웁니다.
```

2. **LSP Protocol Explanation:**
- `textDocument/hover` 요청 구조
- HoverParams (TextDocumentIdentifier + Position)
- Hover 응답 구조 (Contents + Range)
- MarkupContent (Markdown 지원)

3. **Implementation Strategy:**
- 위치 기반 AST 조회의 필요성
- 키워드 hover vs 표현식 hover
- 타입 추론 결과 활용

4. **Position Mapping Pitfall (CRITICAL):**
```markdown
## 위치 변환 주의사항

LSP와 FunLang은 다른 좌표계를 사용합니다:

| 항목 | LSP | FunLang (Span) |
|------|-----|----------------|
| 첫 번째 줄 | 0 | 1 |
| 첫 번째 열 | 0 | 1 |

이 차이를 무시하면 hover가 잘못된 위치에서 트리거됩니다.

```fsharp
// LSP Position (0-based) -> FunLang (1-based)
let line = int lspPos.Line + 1
let col = int lspPos.Character + 1
```
```

5. **Code Examples from Implementation:**

Section A: AST 위치 조회 (AstLookup.fs)
```markdown
### AST 위치 조회

커서 위치에 해당하는 AST 노드를 찾아야 합니다:

```fsharp
/// LSP Position이 Span 내에 있는지 확인
let positionInSpan (lspPos: Position) (span: Span) : bool =
    let line = int lspPos.Line + 1
    let col = int lspPos.Character + 1
    // ... 범위 확인 로직
```
```

Section B: 키워드 설명 (Hover.fs)
```markdown
### 키워드 Hover

키워드는 AST에 포함되지 않으므로 별도로 처리합니다:

```fsharp
let keywordExplanations = Map.ofList [
    ("let", "변수 또는 함수를 정의합니다.\n예: `let x = 5`")
    ("if", "조건 분기를 수행합니다.\n예: `if x > 0 then 1 else -1`")
    // ...
]
```
```

Section C: 타입 정보 표시 (Hover.fs)
```markdown
### 타입 Hover

변수나 함수 위에서는 타입 정보를 표시합니다:

```fsharp
let createTypeHover (ty: Type.Type) (span: Span) : Hover =
    let typeStr = Type.formatTypeNormalized ty
    {
        Contents = U2.C2 {
            Kind = MarkupKind.Markdown
            Value = sprintf "```funlang\n%s\n```" typeStr
        }
        Range = Some (Protocol.spanToLspRange span)
    }
```
```

6. **Integration with Server:**
- 서버 capabilities에 HoverProvider 등록
- 핸들러 연결

7. **Testing Strategy:**
```markdown
## 테스트

Hover 기능은 다음을 테스트해야 합니다:

1. 키워드 hover - "let", "if" 등에서 설명 표시
2. 변수 hover - 추론된 타입 표시 (예: `int`)
3. 함수 hover - 시그니처 표시 (예: `int -> int`)
4. 다형 함수 - 타입 변수 표시 (예: `'a -> 'a`)
5. 범위 밖 - None 반환
```

8. **Common Pitfalls:**
- 0-based vs 1-based 좌표 혼동
- 파싱 실패 시 None 반환 누락
- MarkupKind.PlainText vs Markdown (항상 Markdown 사용 권장)

9. **Summary:**
```markdown
## 정리

Hover 구현의 핵심은:
1. **위치 변환** - LSP (0-based) ↔ FunLang (1-based) 변환
2. **키워드 우선** - 키워드 체크 후 AST 조회
3. **타입 포맷팅** - `formatTypeNormalized`로 깔끔하게 표시
4. **Markdown 사용** - 구문 강조를 위해 코드 펜스 사용
```

10. **Next Steps:**
```markdown
## 다음 단계

→ [07. Go to Definition 구현하기](07-definition.md)
```

**Writing Guidelines:**
- Use actual code from Hover.fs and AstLookup.fs
- Include complete function signatures, not just snippets
- Explain WHY decisions were made, not just WHAT
- Target audience: LSP beginners who may not know F#
- Total length: 250-350 lines
  </action>
  <verify>
    cat docs/06-hover.md | wc -l
    # Verify file exists and has substantial content (> 200 lines)
  </verify>
  <done>
    - docs/06-hover.md exists with Korean content
    - Tutorial covers: position mapping, keyword hover, type hover, testing
    - Code examples reference actual implementation files
    - Minimum 200 lines of content
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify tutorial accuracy against implementation</name>
  <files>
    docs/06-hover.md
  </files>
  <action>
Cross-reference tutorial code examples with actual implementation:

1. **Check AstLookup references:**
   - Function names match exported functions
   - Position conversion logic matches implementation

2. **Check Hover.fs references:**
   - keywordExplanations map content matches
   - handleHover flow matches actual implementation
   - createTypeHover structure matches

3. **Check Protocol.fs references:**
   - spanToLspRange is correctly documented

4. **Verify Korean terminology consistency:**
   - "위치" for position
   - "범위" for range/span
   - "타입" for type
   - "함수" for function

If any discrepancies found, update the tutorial to match actual implementation.
  </action>
  <verify>
    # Manual verification - compare code snippets in tutorial with actual files
    grep -o "let.*=" docs/06-hover.md | head -5
  </verify>
  <done>
    - All code examples compile (or would compile)
    - Function names match actual exports
    - Korean terminology is consistent throughout
  </done>
</task>

</tasks>

<verification>
1. `docs/06-hover.md` exists
2. File contains > 200 lines of Korean content
3. Code examples reference real functions from Hover.fs and AstLookup.fs
4. Position mapping pitfall (0-based vs 1-based) is clearly explained
</verification>

<success_criteria>
- Tutorial explains Hover implementation with code examples (TUT-06)
- Korean language throughout
- Position mapping pitfall clearly documented
- Actual code from implementation used as examples
- Tutorial is actionable - reader could implement similar feature
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-navigation/02-04-SUMMARY.md`
</output>
