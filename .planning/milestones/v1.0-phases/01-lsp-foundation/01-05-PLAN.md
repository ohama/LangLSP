---
phase: 01-lsp-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - src/LangLSP.Server/Diagnostics.fs
  - src/LangLSP.Server/LangLSP.Server.fsproj
  - src/LangLSP.Server/Server.fs
  - src/LangLSP.Tests/DiagnosticsTests.fs
  - src/LangLSP.Tests/ProtocolTests.fs
  - src/LangLSP.Tests/LangLSP.Tests.fsproj
autonomous: true

must_haves:
  truths:
    - "Syntax errors show red squiggles with error messages"
    - "Type errors show red squiggles with type mismatch details"
    - "Diagnostics update without saving file (on didChange)"
    - "Diagnostics clear when file is closed"
    - "All Diagnostics unit tests pass"
    - "FsCheck property tests pass for position conversion"
  artifacts:
    - path: "src/LangLSP.Server/Diagnostics.fs"
      provides: "Diagnostics publishing module"
      exports: ["publishDiagnostics"]
      min_lines: 40
    - path: "src/LangLSP.Tests/DiagnosticsTests.fs"
      provides: "Diagnostics unit tests"
      contains: "testList"
      min_lines: 50
    - path: "src/LangLSP.Tests/ProtocolTests.fs"
      provides: "FsCheck property tests for position conversion"
      contains: "testPropertyWithConfig"
      min_lines: 30
  key_links:
    - from: "src/LangLSP.Server/Diagnostics.fs"
      to: "LangTutorial/FunLang/TypeCheck.fs"
      via: "typecheckWithDiagnostic call"
      pattern: "TypeCheck.typecheckWithDiagnostic"
    - from: "src/LangLSP.Server/Diagnostics.fs"
      to: "src/LangLSP.Server/Protocol.fs"
      via: "diagnosticToLsp conversion"
      pattern: "Protocol.diagnosticToLsp"
    - from: "src/LangLSP.Server/DocumentSync.fs"
      to: "src/LangLSP.Server/Diagnostics.fs"
      via: "publishDiagnostics on change"
      pattern: "Diagnostics.publishDiagnostics"
---

<objective>
Implement real-time diagnostics publishing for syntax and type errors, integrating FunLang's type checker with LSP's publishDiagnostics notification.

Purpose: This is the core user-facing feature - seeing errors as you type without saving.
Output: Working diagnostics with comprehensive unit tests and property-based tests for position conversion.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-lsp-foundation/01-RESEARCH.md
@.planning/phases/01-lsp-foundation/01-01-SUMMARY.md
@.planning/phases/01-lsp-foundation/01-03-SUMMARY.md

# FunLang source files
@LangTutorial/FunLang/TypeCheck.fs
@LangTutorial/FunLang/Diagnostic.fs
@LangTutorial/FunLang/Ast.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Diagnostics Module</name>
  <files>
    src/LangLSP.Server/Diagnostics.fs
    src/LangLSP.Server/LangLSP.Server.fsproj
  </files>
  <action>
Create Diagnostics.fs to parse/typecheck and publish diagnostics:

```fsharp
module LangLSP.Server.Diagnostics

open System
open FSharp.Text.Lexing
open Ionide.LanguageServerProtocol.Types
open LangLSP.Server.Protocol

/// Parse FunLang source and collect any syntax errors
let private parseFunLang (text: string) (filename: string) : Result<Ast.Expr, Diagnostic> =
    try
        let lexbuf = LexBuffer<char>.FromString(text)
        lexbuf.EndPos <- { lexbuf.EndPos with FileName = filename }
        let ast = Parser.program Lexer.token lexbuf
        Ok ast
    with
    | ex ->
        // Create syntax error diagnostic
        // Note: FsLexYacc errors have position info in the exception
        let range : Range = {
            Start = { Line = 0u; Character = 0u }
            End = { Line = 0u; Character = 0u }
        }
        let diagnostic : Diagnostic = {
            Range = range
            Severity = Some DiagnosticSeverity.Error
            Code = Some (U2.C1 "E0001")
            CodeDescription = None
            Source = Some "funlang"
            Message = sprintf "Syntax error: %s" ex.Message
            Tags = None
            RelatedInformation = None
            Data = None
        }
        Error diagnostic

/// Type check parsed AST and return diagnostics
let private typecheckAst (ast: Ast.Expr) : Diagnostic list =
    match TypeCheck.typecheckWithDiagnostic ast with
    | Ok _ -> []  // No type errors
    | Error diag ->
        [diagnosticToLsp diag]

/// Analyze document and return all diagnostics
let analyze (text: string) (uri: string) : Diagnostic[] =
    // Extract filename from URI (strip file:// prefix)
    let filename =
        if uri.StartsWith("file://") then uri.Substring(7)
        else uri

    match parseFunLang text filename with
    | Error syntaxDiag ->
        // Syntax error - return just that
        [| syntaxDiag |]
    | Ok ast ->
        // Parse succeeded, now type check
        typecheckAst ast |> Array.ofList

/// Publish diagnostics callback type
type PublishDiagnosticsCallback = PublishDiagnosticsParams -> unit

/// Publish diagnostics for a document
let publishDiagnostics (publish: PublishDiagnosticsCallback) (uri: string) (text: string) : unit =
    let diagnostics = analyze text uri
    let params : PublishDiagnosticsParams = {
        Uri = uri
        Version = None
        Diagnostics = diagnostics
    }
    publish params

/// Clear diagnostics for a document (on close)
let clearDiagnostics (publish: PublishDiagnosticsCallback) (uri: string) : unit =
    let params : PublishDiagnosticsParams = {
        Uri = uri
        Version = None
        Diagnostics = [||]
    }
    publish params
```

Update LangLSP.Server.fsproj compile order:
Protocol.fs -> DocumentSync.fs -> Diagnostics.fs -> Server.fs -> Program.fs
  </action>
  <verify>
`dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` compiles without errors
  </verify>
  <done>
Diagnostics.fs provides analyze, publishDiagnostics, and clearDiagnostics functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Diagnostics to Document Sync</name>
  <files>
    src/LangLSP.Server/DocumentSync.fs
    src/LangLSP.Server/Server.fs
  </files>
  <action>
Modify DocumentSync.fs to trigger diagnostics on document changes:

Option A: Pass publish callback to DocumentSync handlers
Option B: Use events/observers pattern
Option C: Call Diagnostics module directly from Server.fs after DocumentSync

Recommended approach (Option C - simpler):

Update Server.fs to orchestrate:
1. On didOpen: Store document, then publish diagnostics
2. On didChange: Update document, then publish diagnostics
3. On didClose: Remove document, then clear diagnostics

```fsharp
// In Server.fs
let handleDidOpenWithDiagnostics (publishCallback) (p: DidOpenTextDocumentParams) =
    DocumentSync.handleDidOpen p
    match DocumentSync.getDocument p.TextDocument.Uri with
    | Some text -> Diagnostics.publishDiagnostics publishCallback p.TextDocument.Uri text
    | None -> ()

let handleDidChangeWithDiagnostics (publishCallback) (p: DidChangeTextDocumentParams) =
    DocumentSync.handleDidChange p
    match DocumentSync.getDocument p.TextDocument.Uri with
    | Some text -> Diagnostics.publishDiagnostics publishCallback p.TextDocument.Uri text
    | None -> ()

let handleDidCloseWithDiagnostics (publishCallback) (p: DidCloseTextDocumentParams) =
    Diagnostics.clearDiagnostics publishCallback p.TextDocument.Uri
    DocumentSync.handleDidClose p
```

The publishCallback comes from the LSP server infrastructure - it's how you send notifications to the client.
  </action>
  <verify>
`dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` compiles without errors
  </verify>
  <done>
Document sync events trigger diagnostics publishing
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Diagnostics Unit Tests</name>
  <files>
    src/LangLSP.Tests/DiagnosticsTests.fs
    src/LangLSP.Tests/LangLSP.Tests.fsproj
  </files>
  <action>
Create DiagnosticsTests.fs:

```fsharp
module LangLSP.Tests.DiagnosticsTests

open Expecto
open LangLSP.Server.Diagnostics
open Ionide.LanguageServerProtocol.Types

[<Tests>]
let diagnosticsTests =
    testList "Diagnostics" [

        testCase "valid code produces no diagnostics" <| fun _ ->
            let code = "let x = 1 in x + 2"
            let diagnostics = analyze code "test.fun"
            Expect.isEmpty diagnostics "Valid code should have no errors"

        testCase "syntax error produces diagnostic" <| fun _ ->
            let code = "let x = in x"  // Missing expression after '='
            let diagnostics = analyze code "test.fun"
            Expect.isNonEmpty diagnostics "Syntax error should produce diagnostic"
            Expect.equal diagnostics.[0].Severity (Some DiagnosticSeverity.Error) "Should be error"
            Expect.stringContains diagnostics.[0].Message "Syntax" "Should mention syntax"

        testCase "type error produces diagnostic" <| fun _ ->
            let code = "let x = 1 in x + true"  // Int + Bool
            let diagnostics = analyze code "test.fun"
            Expect.isNonEmpty diagnostics "Type error should produce diagnostic"
            Expect.stringContains diagnostics.[0].Message "mismatch" "Should mention type mismatch"

        testCase "unbound variable produces diagnostic" <| fun _ ->
            let code = "x + 1"  // x not defined
            let diagnostics = analyze code "test.fun"
            Expect.isNonEmpty diagnostics "Unbound variable should produce diagnostic"
            Expect.stringContains diagnostics.[0].Message "Unbound" "Should mention unbound"

        testCase "diagnostic has correct source" <| fun _ ->
            let code = "let x = true + 1 in x"
            let diagnostics = analyze code "test.fun"
            Expect.isNonEmpty diagnostics "Should have diagnostic"
            Expect.equal diagnostics.[0].Source (Some "funlang") "Source should be funlang"

        testCase "diagnostic range is 0-based" <| fun _ ->
            let code = "let x = 1 in y"  // 'y' is unbound, at column 13-14
            let diagnostics = analyze code "test.fun"
            Expect.isNonEmpty diagnostics "Should have diagnostic"
            // LSP uses 0-based positions
            Expect.equal diagnostics.[0].Range.Start.Line 0u "Line should be 0"
    ]
```

Update LangLSP.Tests.fsproj to include DiagnosticsTests.fs in compile order.
  </action>
  <verify>
`dotnet test src/LangLSP.Tests/LangLSP.Tests.fsproj` runs all Diagnostics tests and they pass
  </verify>
  <done>
6 Diagnostics unit tests exist and pass
  </done>
</task>

<task type="auto">
  <name>Task 4: Create FsCheck Property Tests for Position Conversion</name>
  <files>
    src/LangLSP.Tests/ProtocolTests.fs
    src/LangLSP.Tests/LangLSP.Tests.fsproj
  </files>
  <action>
Create ProtocolTests.fs with FsCheck property-based tests:

```fsharp
module LangLSP.Tests.ProtocolTests

open Expecto
open FsCheck
open LangLSP.Server.Protocol
open Ast

let config = { FsCheckConfig.defaultConfig with maxTest = 500 }

/// Generator for valid Span values (1-based, positive, start <= end)
let spanGen =
    gen {
        let! startLine = Gen.choose(1, 100)
        let! startCol = Gen.choose(1, 80)
        let! lineDiff = Gen.choose(0, 10)
        let endLine = startLine + lineDiff
        let! endCol =
            if lineDiff = 0 then Gen.choose(startCol, 80)
            else Gen.choose(1, 80)
        return {
            FileName = "test.fun"
            StartLine = startLine
            StartColumn = startCol
            EndLine = endLine
            EndColumn = endCol
        }
    }

[<Tests>]
let protocolTests =
    testList "Protocol Position Conversion" [

        testPropertyWithConfig config "spanToLspRange converts to 0-based" <| fun () ->
            Prop.forAll (Arb.fromGen spanGen) (fun span ->
                let range = spanToLspRange span
                // LSP is 0-based, Span is 1-based
                int range.Start.Line = span.StartLine - 1
                && int range.Start.Character = span.StartColumn - 1
                && int range.End.Line = span.EndLine - 1
                && int range.End.Character = span.EndColumn - 1
            )

        testPropertyWithConfig config "spanToLspRange preserves line ordering" <| fun () ->
            Prop.forAll (Arb.fromGen spanGen) (fun span ->
                let range = spanToLspRange span
                range.Start.Line <= range.End.Line
            )

        testPropertyWithConfig config "spanToLspRange same line preserves character ordering" <| fun () ->
            Prop.forAll (Arb.fromGen spanGen) (fun span ->
                let range = spanToLspRange span
                if range.Start.Line = range.End.Line then
                    range.Start.Character <= range.End.Character
                else
                    true  // Multi-line ranges don't need this check
            )

        testCase "spanToLspRange first line first column" <| fun _ ->
            let span = { FileName = "test.fun"; StartLine = 1; StartColumn = 1; EndLine = 1; EndColumn = 5 }
            let range = spanToLspRange span
            Expect.equal range.Start.Line 0u "First line should be 0"
            Expect.equal range.Start.Character 0u "First column should be 0"
    ]
```

Update LangLSP.Tests.fsproj compile order to include ProtocolTests.fs.
  </action>
  <verify>
`dotnet test src/LangLSP.Tests/LangLSP.Tests.fsproj` runs all property tests (500 iterations each) and passes
  </verify>
  <done>
FsCheck property tests verify Span-to-LSP conversion for 500+ random cases
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` succeeds
2. `dotnet test src/LangLSP.Tests/LangLSP.Tests.fsproj` passes all tests (Document Sync + Diagnostics + Protocol)
3. Diagnostics.analyze returns errors for syntax errors, type errors, and unbound variables
4. FsCheck tests run 500 iterations for position conversion
</verification>

<success_criteria>
- Syntax errors detected and converted to LSP Diagnostics
- Type errors detected using FunLang's TypeCheck.typecheckWithDiagnostic
- Position conversion tested with FsCheck (1-based to 0-based)
- All unit tests pass
- Diagnostics cleared on document close
</success_criteria>

<output>
After completion, create `.planning/phases/01-lsp-foundation/01-05-SUMMARY.md`
</output>
