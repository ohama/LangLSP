---
phase: 01-lsp-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - documentation/tutorial/01-lsp-concepts.md
  - documentation/tutorial/02-library-choice.md
autonomous: true

must_haves:
  truths:
    - "Reader understands LSP client-server architecture"
    - "Reader understands JSON-RPC message format"
    - "Reader understands capability negotiation"
    - "Reader knows why Ionide.LanguageServerProtocol was chosen over OmniSharp"
  artifacts:
    - path: "documentation/tutorial/01-lsp-concepts.md"
      provides: "LSP fundamentals tutorial in Korean"
      contains: "JSON-RPC"
      min_lines: 100
    - path: "documentation/tutorial/02-library-choice.md"
      provides: "Library comparison tutorial in Korean"
      contains: "Ionide"
      min_lines: 50
  key_links: []
---

<objective>
Write Korean tutorials explaining LSP fundamentals and F# library choices for LSP implementation.

Purpose: Provides conceptual foundation for readers before diving into implementation. Addresses the gap in Korean LSP resources.
Output: Two tutorial documents covering LSP concepts and library selection rationale.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-lsp-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write LSP Concepts Tutorial (TUT-01)</name>
  <files>documentation/tutorial/01-lsp-concepts.md</files>
  <action>
Create `documentation/tutorial/` directory if it doesn't exist.

Write `01-lsp-concepts.md` in Korean covering:

1. **LSP란 무엇인가** (What is LSP)
   - Language Server Protocol의 목적
   - 에디터 종속성 문제 해결 (M x N -> M + N)
   - Microsoft에서 시작, 현재 표준으로 정착

2. **클라이언트-서버 아키텍처** (Client-Server Architecture)
   - 클라이언트: VS Code, Neovim, Emacs 등 에디터
   - 서버: 언어별 분석 엔진 (별도 프로세스)
   - 두 프로세스 간 통신 (stdin/stdout, socket, pipe)
   - 다이어그램: [VS Code] <-- JSON-RPC --> [Language Server]

3. **JSON-RPC 프로토콜** (JSON-RPC Protocol)
   - JSON-RPC 2.0 기반
   - 메시지 형식: Content-Length 헤더 + JSON body
   - Request/Response/Notification 구분
   - 예시: initialize request/response

4. **Capability Negotiation** (기능 협상)
   - 클라이언트가 지원하는 기능 알림
   - 서버가 제공하는 기능 선언
   - textDocument/sync, hover, completion 등
   - ServerCapabilities 구조 설명

5. **Document Synchronization** (문서 동기화)
   - didOpen, didChange, didClose 이벤트
   - Full sync vs Incremental sync
   - 왜 Incremental이 더 효율적인지

6. **실시간 진단** (Real-time Diagnostics)
   - textDocument/publishDiagnostics 알림
   - Diagnostic 구조 (range, severity, message)
   - 에러, 경고, 정보 수준

Include diagrams using ASCII art or Mermaid syntax where helpful.
Target length: 150-200 lines of well-formatted Markdown.
  </action>
  <verify>
File exists at `documentation/tutorial/01-lsp-concepts.md` with all 6 sections, Korean text, and at least 100 lines
  </verify>
  <done>
Tutorial covers LSP architecture, JSON-RPC, capabilities, document sync, and diagnostics in Korean
  </done>
</task>

<task type="auto">
  <name>Task 2: Write Library Choice Tutorial (TUT-02)</name>
  <files>documentation/tutorial/02-library-choice.md</files>
  <action>
Write `02-library-choice.md` in Korean covering:

1. **F# LSP 라이브러리 옵션** (F# LSP Library Options)
   - Ionide.LanguageServerProtocol
   - OmniSharp.LanguageServerProtocol
   - 직접 구현 (Custom implementation)

2. **Ionide.LanguageServerProtocol 소개**
   - F# 네이티브 (F#으로 작성됨)
   - Ionide 프로젝트 일부 (FsAutoComplete에서 사용)
   - 경량, LSP 3.17 지원
   - 버전 0.7.0 (2025-03-12 릴리스)

3. **OmniSharp 대비 장점**
   | 비교 항목 | Ionide | OmniSharp |
   |-----------|--------|-----------|
   | 언어 | F# | C# |
   | DI 의존성 | 없음 | Microsoft.Extensions.DI |
   | 설계 철학 | 함수형 | OOP |
   | 학습 곡선 | 낮음 | 높음 |
   | 커뮤니티 | F# 중심 | C# 중심 |

4. **직접 구현을 피해야 하는 이유**
   - LSP 스펙: 285페이지, 90개 메서드, 407개 타입
   - Content-Length 파싱, UTF-16 인코딩 등 엣지 케이스
   - 바퀴의 재발명 회피

5. **결론: Ionide.LanguageServerProtocol 선택**
   - FunLang이 F#이므로 자연스러운 선택
   - FsAutoComplete가 프로덕션에서 검증
   - 이 튜토리얼 시리즈에서 사용

Include code snippet showing minimal Ionide usage pattern.
Target length: 80-120 lines.
  </action>
  <verify>
File exists at `documentation/tutorial/02-library-choice.md` with comparison table, Korean text, and at least 50 lines
  </verify>
  <done>
Tutorial explains library choices with comparison table and rationale for Ionide selection
  </done>
</task>

</tasks>

<verification>
1. `documentation/tutorial/01-lsp-concepts.md` exists with 6 sections in Korean
2. `documentation/tutorial/02-library-choice.md` exists with comparison table
3. Both files are well-formatted Markdown
4. Content is accurate based on research findings
</verification>

<success_criteria>
- LSP concepts tutorial explains client-server architecture, JSON-RPC, capabilities
- Library choice tutorial compares Ionide vs OmniSharp with clear rationale
- All content in Korean as specified
- Tutorials can be read standalone without code implementation
</success_criteria>

<output>
After completion, create `.planning/phases/01-lsp-foundation/01-02-SUMMARY.md`
</output>
