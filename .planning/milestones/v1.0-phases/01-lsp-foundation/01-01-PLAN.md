---
phase: 01-lsp-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/LangLSP.Server/LangLSP.Server.fsproj
  - src/LangLSP.Server/Protocol.fs
  - src/LangLSP.Server/Server.fs
  - src/LangLSP.Server/Program.fs
  - LangLSP.sln
autonomous: true

must_haves:
  truths:
    - "F# project compiles with Ionide.LanguageServerProtocol 0.7.0"
    - "Span to LSP Position/Range conversion works correctly (1-based to 0-based)"
    - "Server starts and listens on stdin/stdout"
  artifacts:
    - path: "src/LangLSP.Server/LangLSP.Server.fsproj"
      provides: "F# project with LSP dependencies"
      contains: "Ionide.LanguageServerProtocol"
    - path: "src/LangLSP.Server/Protocol.fs"
      provides: "Span/Position/Range conversion utilities"
      exports: ["spanToLspRange", "diagnosticToLsp"]
    - path: "src/LangLSP.Server/Server.fs"
      provides: "LSP server initialization with capabilities"
      contains: "InitializeResult"
    - path: "src/LangLSP.Server/Program.fs"
      provides: "Server entry point with stdin/stdout"
      contains: "OpenStandardInput"
  key_links:
    - from: "src/LangLSP.Server/Protocol.fs"
      to: "LangTutorial/FunLang/Ast.fs"
      via: "Span type import"
      pattern: "open Ast"
    - from: "src/LangLSP.Server/LangLSP.Server.fsproj"
      to: "LangTutorial/FunLang/FunLang.fsproj"
      via: "ProjectReference"
      pattern: "ProjectReference.*FunLang"
---

<objective>
Create the F# LSP Server project with Ionide.LanguageServerProtocol, implementing the Protocol module for Span-to-LSP type conversions and basic server initialization.

Purpose: Establishes the foundation for all subsequent LSP functionality. The Protocol module handles the critical 1-based to 0-based position conversion.
Output: Compilable F# project that starts an LSP server listening on stdin/stdout with declared capabilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-lsp-foundation/01-RESEARCH.md

# FunLang source files for understanding Span/Diagnostic types
@LangTutorial/FunLang/Ast.fs
@LangTutorial/FunLang/Diagnostic.fs
@LangTutorial/FunLang/TypeCheck.fs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create F# LSP Server Project</name>
  <files>
    src/LangLSP.Server/LangLSP.Server.fsproj
    LangLSP.sln
  </files>
  <action>
Create the F# console application project for the LSP server:

1. Create directory structure: `src/LangLSP.Server/`

2. Create `LangLSP.Server.fsproj` with:
   - TargetFramework: net10.0
   - OutputType: Exe
   - PackageReferences:
     - Ionide.LanguageServerProtocol 0.7.0
     - Serilog 4.x (for logging)
     - Serilog.Sinks.File
   - ProjectReference to `../../LangTutorial/FunLang/FunLang.fsproj`
   - Compile order: Protocol.fs, Server.fs, Program.fs

3. Create solution file `LangLSP.sln` (or add to existing) that includes:
   - src/LangLSP.Server/LangLSP.Server.fsproj

4. Run `dotnet restore` to verify package resolution

IMPORTANT: The Ionide.LanguageServerProtocol 0.7.0 API uses:
- `Ionide.LanguageServerProtocol.Server` namespace
- `ILspServer` interface for implementing handlers
- Type definitions in `Ionide.LanguageServerProtocol.Types`
  </action>
  <verify>
`dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` succeeds (may have warnings about missing files, that's OK)
  </verify>
  <done>
Project file exists with correct dependencies and compiles after empty source files are added
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Protocol Module (Span/Position Conversion)</name>
  <files>src/LangLSP.Server/Protocol.fs</files>
  <action>
Create Protocol.fs with Span-to-LSP conversion utilities:

```fsharp
module LangLSP.Server.Protocol

open Ionide.LanguageServerProtocol.Types
open Ast  // FunLang's Span type

/// Convert FunLang Span (1-based) to LSP Range (0-based)
/// FunLang: StartLine=1 means first line
/// LSP: line=0 means first line
let spanToLspRange (span: Span) : Range =
    {
        Start = { Line = uint32 (span.StartLine - 1); Character = uint32 (span.StartColumn - 1) }
        End = { Line = uint32 (span.EndLine - 1); Character = uint32 (span.EndColumn - 1) }
    }

/// Convert FunLang Diagnostic to LSP Diagnostic
let diagnosticToLsp (diag: Diagnostic.Diagnostic) : Diagnostic =
    {
        Range = spanToLspRange diag.PrimarySpan
        Severity = Some DiagnosticSeverity.Error
        Code = diag.Code |> Option.map (fun c -> U2.C1 c)  // Code as string
        CodeDescription = None
        Source = Some "funlang"
        Message = diag.Message
        Tags = None
        RelatedInformation =
            if List.isEmpty diag.SecondarySpans then None
            else
                diag.SecondarySpans
                |> List.map (fun (span, label) ->
                    {
                        Location = {
                            Uri = span.FileName  // Will need URI conversion later
                            Range = spanToLspRange span
                        }
                        Message = label
                    })
                |> Array.ofList
                |> Some
        Data = None
    }
```

NOTE: Check Ionide.LanguageServerProtocol 0.7.0 exact type names. The types may be slightly different from research examples. Use IDE completion or check the package source.
  </action>
  <verify>
`dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` compiles Protocol.fs without errors
  </verify>
  <done>
Protocol.fs exists with spanToLspRange and diagnosticToLsp functions that compile against Ionide.LanguageServerProtocol types
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Server Initialization and Entry Point</name>
  <files>
    src/LangLSP.Server/Server.fs
    src/LangLSP.Server/Program.fs
  </files>
  <action>
Create Server.fs with LSP server initialization:

```fsharp
module LangLSP.Server.Server

open Ionide.LanguageServerProtocol
open Ionide.LanguageServerProtocol.Server
open Ionide.LanguageServerProtocol.Types

/// Server capabilities declaration
let serverCapabilities : ServerCapabilities =
    { ServerCapabilities.Default with
        TextDocumentSync =
            Some (U2.C1 {
                OpenClose = Some true
                Change = Some TextDocumentSyncKind.Incremental
                Save = Some (U2.C2 { IncludeText = Some false })
                WillSave = None
                WillSaveWaitUntil = None
            })
    }

/// Handle initialize request
let onInitialize (p: InitializeParams) : Async<Result<InitializeResult, ResponseError>> =
    async {
        let result : InitializeResult = {
            Capabilities = serverCapabilities
            ServerInfo = Some { Name = "funlang-lsp"; Version = Some "0.1.0" }
        }
        return Ok result
    }
```

Create Program.fs entry point:

```fsharp
module LangLSP.Server.Program

open System
open Ionide.LanguageServerProtocol.Server

[<EntryPoint>]
let main argv =
    // Set up stdin/stdout for LSP communication
    let input = Console.OpenStandardInput()
    let output = Console.OpenStandardOutput()

    // Create and start server
    // NOTE: Check Ionide.LanguageServerProtocol 0.7.0 API for exact server creation
    // The API may use LspServer.start or similar

    0  // Exit code
```

IMPORTANT: The exact Ionide.LanguageServerProtocol 0.7.0 server creation API needs verification. Look at:
- FsAutoComplete source for reference
- The package's GitHub examples
- Type signature of server creation functions

The server creation pattern in 0.7.0 may differ from older versions. Focus on getting a compilable skeleton that can be refined.
  </action>
  <verify>
`dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` succeeds and `dotnet run --project src/LangLSP.Server/LangLSP.Server.fsproj` starts without immediate crash (will hang waiting for stdin, Ctrl+C to exit)
  </verify>
  <done>
Server.fs declares capabilities, Program.fs provides entry point, project compiles and runs
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/LangLSP.Server/LangLSP.Server.fsproj` - compiles without errors
2. `dotnet run --project src/LangLSP.Server/LangLSP.Server.fsproj` - starts and waits for input (Ctrl+C to exit)
3. Protocol.fs contains spanToLspRange and diagnosticToLsp functions
4. Server.fs declares TextDocumentSync capability with Incremental mode
</verification>

<success_criteria>
- F# LSP Server project compiles with all dependencies resolved
- Protocol module converts FunLang Span (1-based) to LSP Range (0-based)
- Server declares textDocument/sync capability with Incremental mode
- Program entry point reads from stdin/writes to stdout
</success_criteria>

<output>
After completion, create `.planning/phases/01-lsp-foundation/01-01-SUMMARY.md`
</output>
