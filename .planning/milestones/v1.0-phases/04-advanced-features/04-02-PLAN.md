---
phase: 04-advanced-features
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/LangLSP.Server/Rename.fs
  - src/LangLSP.Server/CodeActions.fs
  - src/LangLSP.Server/Diagnostics.fs
  - src/LangLSP.Server/Server.fs
  - src/LangLSP.Server/LangLSP.Server.fsproj
autonomous: true

must_haves:
  truths:
    - "User invokes 'Rename Symbol' on a variable and all usages update to the new name simultaneously"
    - "User invokes 'Rename Symbol' on a non-renameable token (number, keyword) and VS Code grays out the rename command"
    - "User sees faded/dimmed text on unused variables with a lightbulb offering 'Prefix with underscore' quickfix"
    - "User sees lightbulb on type error diagnostics with an informational code action showing the expected type"
    - "Unused variable warnings appear as Warning severity (yellow squiggle), not Error (red squiggle)"
  artifacts:
    - path: "src/LangLSP.Server/Rename.fs"
      provides: "Rename Symbol implementation"
      exports: ["handleRename", "handlePrepareRename"]
    - path: "src/LangLSP.Server/CodeActions.fs"
      provides: "Code Actions implementation"
      exports: ["handleCodeAction"]
    - path: "src/LangLSP.Server/Diagnostics.fs"
      provides: "Updated diagnostics with unused variable detection"
      exports: ["findUnusedVariables"]
  key_links:
    - from: "src/LangLSP.Server/Rename.fs"
      to: "References.collectReferencesForBinding"
      via: "import and call for collecting rename targets"
      pattern: "collectReferencesForBinding"
    - from: "src/LangLSP.Server/Rename.fs"
      to: "Protocol.createWorkspaceEdit"
      via: "import and call for building WorkspaceEdit"
      pattern: "createWorkspaceEdit"
    - from: "src/LangLSP.Server/CodeActions.fs"
      to: "Diagnostics context"
      via: "reads diagnostics from CodeActionParams.Context"
      pattern: "p\\.Context\\.Diagnostics"
    - from: "src/LangLSP.Server/Server.fs"
      to: "Rename and CodeActions handlers"
      via: "handler registration"
      pattern: "handleRename|handleCodeAction"
---

<objective>
Implement Rename Symbol (RENAME-01, RENAME-02, RENAME-03) and Code Actions (ACTION-01, ACTION-02) features.

Purpose: Users need to safely rename variables across all usages and receive quickfix suggestions for code issues. Rename builds on References (Plan 01), Code Actions integrate with diagnostics.
Output: Rename.fs with rename + prepareRename, CodeActions.fs with quickfix generation (unused variable prefix + type error info), Diagnostics.fs with unused variable detection, Server.fs fully registered.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-advanced-features/04-RESEARCH.md
@.planning/phases/04-advanced-features/04-01-SUMMARY.md
@src/LangLSP.Server/References.fs
@src/LangLSP.Server/Protocol.fs
@src/LangLSP.Server/Definition.fs
@src/LangLSP.Server/Diagnostics.fs
@src/LangLSP.Server/Server.fs
@src/LangLSP.Server/AstLookup.fs
@src/LangLSP.Server/LangLSP.Server.fsproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Rename.fs with rename and prepareRename handlers</name>
  <files>src/LangLSP.Server/Rename.fs</files>
  <action>
Create `src/LangLSP.Server/Rename.fs` as module `LangLSP.Server.Rename`.

Open: Ionide.LanguageServerProtocol.Types, LangLSP.Server.AstLookup, LangLSP.Server.Definition, LangLSP.Server.References, LangLSP.Server.DocumentSync, LangLSP.Server.Protocol, Ast

Implement a helper and two handler functions:

**Helper: `findNameInSource`** -- Given document text and a definition span, find the exact character range of the identifier name within the first ~15 characters of the span start. This is needed because AST spans for binding sites (Let, LetRec, Lambda) cover the whole expression, but rename needs to edit just the name.

```fsharp
let findNameInSource (text: string) (name: string) (startLine: int) (startCol: int) : Span option =
    let lines = text.Split('\n')
    if startLine < lines.Length then
        let line = lines.[startLine]
        // Search for name within the first 15 chars from startCol
        let searchEnd = min (startCol + 15) line.Length
        let searchArea = line.Substring(startCol, searchEnd - startCol)
        let idx = searchArea.IndexOf(name)
        if idx >= 0 then
            let nameStart = startCol + idx
            Some {
                FileName = ""
                StartLine = startLine
                StartColumn = nameStart
                EndLine = startLine
                EndColumn = nameStart + name.Length - 1
            }
        else None
    else None
```

**1. `handlePrepareRename (p: PrepareRenameParams) : Async<PrepareRenameResult option>`**
   - Get document from getDocument p.TextDocument.Uri
   - Parse AST from document text
   - Find node at p.Position with findNodeAtPosition
   - Match on node:
     - Var(name, span) -> return Some (U3.C2 { Range = spanToLspRange span; Placeholder = name })
     - Let(name, _, _, span) -> return Some with placeholder = name (use findNameInSource to get tight range for the name, fall back to span start)
     - LetRec(name, _, _, _, span) -> same approach
     - Lambda(param, _, span) -> same approach
     - LambdaAnnot(param, _, _, span) -> same approach
     - _ -> return None (not a renameable symbol: numbers, keywords, operators)
   - Wrap in try/with _ -> return None

   NOTE on PrepareRenameParams: Check the Ionide 0.7.0 types. PrepareRenameParams may be `TextDocumentPositionParams` or a separate type. Use whatever type the library provides.

**2. `handleRename (p: RenameParams) : Async<WorkspaceEdit option>`**
   - Get document from getDocument p.TextDocument.Uri
   - Parse AST
   - Find node at p.Position with findNodeAtPosition
   - Determine varName and defSpan:
     - If Var(name, _): look up definition with findDefinitionForVar name ast p.Position
     - If binding site (Let, LetRec, Lambda, LambdaAnnot): use node's own span as defSpan, get name from node
   - If no varName or no defSpan, return None
   - Collect scoped references: collectReferencesForBinding varName defSpan ast
   - For the definition site, use `findNameInSource` to get the name-only span from the source text (Var spans are already tight around the name; definition binding spans need this conversion)
   - Build allSpans = nameSpanFromDef :: references
   - Remove duplicates: List.distinctBy to avoid duplicate spans
   - Create TextEdit[] from allSpans: each edit replaces span range with p.NewName using Protocol.createTextEdit
   - Create WorkspaceEdit: Protocol.createWorkspaceEdit p.TextDocument.Uri (Array.ofList edits)
   - Return Some workspaceEdit
   - Wrap in try/with _ -> return None

IMPORTANT: Var node spans are already tight around the variable name. Definition binding spans (Let, LetRec, Lambda) cover the whole expression. Use `findNameInSource` for definition sites to get the name-only span for correct rename edits.
  </action>
  <verify>
Module compiles: `dotnet build src/LangLSP.Server/` (after Task 2 adds to fsproj)
  </verify>
  <done>
Rename.fs has handlePrepareRename (validates renameable symbols, returns range+placeholder) and handleRename (collects all references + definition name span via source text search, returns WorkspaceEdit with all edits).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CodeActions.fs, update Diagnostics.fs, complete Server.fs</name>
  <files>src/LangLSP.Server/CodeActions.fs, src/LangLSP.Server/Diagnostics.fs, src/LangLSP.Server/Server.fs, src/LangLSP.Server/LangLSP.Server.fsproj</files>
  <action>
**Diagnostics.fs** -- Add unused variable detection. Add `open LangLSP.Server.References` at the top. Add after the existing `analyze` function a new function:

```fsharp
/// Find unused variables in AST
/// Returns list of (name, span) for let-bound variables not referenced in their body
let findUnusedVariables (ast: Expr) : (string * Ast.Span) list =
    let unused = ResizeArray<string * Ast.Span>()
    let rec traverse expr =
        match expr with
        | Let(name, value, body, span) ->
            let refs = References.collectReferences name body
            if List.isEmpty refs && name <> "_" then
                let nameSpan : Ast.Span = {
                    FileName = span.FileName
                    StartLine = span.StartLine
                    StartColumn = span.StartColumn + 4
                    EndLine = span.StartLine
                    EndColumn = span.StartColumn + 4 + name.Length - 1
                }
                unused.Add(name, nameSpan)
            traverse value
            traverse body
        | LetRec(name, param, fnBody, inExpr, span) ->
            let refsInBody = References.collectReferences name inExpr
            if List.isEmpty refsInBody && name <> "_" then
                let nameSpan : Ast.Span = {
                    FileName = span.FileName
                    StartLine = span.StartLine
                    StartColumn = span.StartColumn + 8
                    EndLine = span.StartLine
                    EndColumn = span.StartColumn + 8 + name.Length - 1
                }
                unused.Add(name, nameSpan)
            traverse fnBody
            traverse inExpr
        | App(fn, arg, _) -> traverse fn; traverse arg
        | If(c, t, e, _) -> traverse c; traverse t; traverse e
        | Lambda(_, body, _) | LambdaAnnot(_, _, body, _) -> traverse body
        | LetPat(_, value, body, _) -> traverse value; traverse body
        | Match(scrutinee, clauses, _) ->
            traverse scrutinee
            for (_, clauseBody) in clauses do traverse clauseBody
        | Add(l,r,_) | Subtract(l,r,_) | Multiply(l,r,_) | Divide(l,r,_)
        | Equal(l,r,_) | NotEqual(l,r,_) | LessThan(l,r,_) | GreaterThan(l,r,_)
        | LessEqual(l,r,_) | GreaterEqual(l,r,_) | And(l,r,_) | Or(l,r,_)
        | Cons(l,r,_) -> traverse l; traverse r
        | Negate(e, _) | Annot(e, _, _) -> traverse e
        | Tuple(exprs, _) | List(exprs, _) -> List.iter traverse exprs
        | Number _ | Bool _ | String _ | Var _ | EmptyList _ -> ()
    traverse ast
    unused |> Seq.toList
```

Then update the `analyze` function to also return unused variable warnings. The updated function:

```fsharp
let analyze (uri: string) (source: string) : Diagnostic list =
    match parseFunLang source uri with
    | Error parseDiag -> [parseDiag]
    | Ok ast ->
        let typeErrors =
            match typecheckAst ast with
            | Ok _ -> []
            | Error typeDiag -> [typeDiag]

        let unusedWarnings =
            findUnusedVariables ast
            |> List.map (fun (name, nameSpan) ->
                {
                    Range = spanToLspRange nameSpan
                    Severity = Some DiagnosticSeverity.Warning
                    Code = Some (U2.C2 "unused-variable")
                    CodeDescription = None
                    Source = Some "funlang"
                    Message = sprintf "Unused variable '%s'" name
                    Tags = Some [| DiagnosticTag.Unnecessary |]
                    RelatedInformation = None
                    Data = None
                })

        typeErrors @ unusedWarnings
```

CRITICAL details for unused variable diagnostics:
- Severity MUST be `DiagnosticSeverity.Warning` (not Error) -- renders as yellow squiggle
- Code MUST be `Some (U2.C2 "unused-variable")` -- used by CodeActions to identify fixable diagnostics
- Tags MUST include `DiagnosticTag.Unnecessary` -- VS Code renders these with faded/dimmed text
- Variables prefixed with `_` (e.g., `_x`) should NOT be flagged as unused (convention for intentionally unused)
- This change WILL affect existing tests that call `analyze` on code with unused variables. Existing tests may now receive additional Warning diagnostics. Plan 03 handles verifying and fixing any test regressions.

**CodeActions.fs** -- Create `src/LangLSP.Server/CodeActions.fs` as module `LangLSP.Server.CodeActions`:

Open: Ionide.LanguageServerProtocol.Types, LangLSP.Server.Protocol

Implement:

1. `createPrefixUnderscoreAction (diag: Diagnostic) (uri: string) : CodeAction`
   - Extract variable name from diag.Message format "Unused variable 'x'" (parse between single quotes)
   - Title: sprintf "Prefix '%s' with underscore" varName
   - Kind: Some "quickfix"
   - Diagnostics: Some [| diag |]
   - IsPreferred: Some true
   - Edit: Some (createWorkspaceEdit uri [| { Range = diag.Range; NewText = "_" + varName } |])
   - Command: None, Data: None, Disabled: None

2. `createTypeInfoAction (diag: Diagnostic) (uri: string) : CodeAction`
   - This handles ACTION-02 (type error code actions). When a "Type mismatch" diagnostic exists, create an informational code action that surfaces the expected type.
   - Extract the expected type from the diagnostic message (format: "Type mismatch: expected X but got Y" or similar from FunLang type checker)
   - Title: sprintf "Expected type: %s" expectedType (informational, helps user understand what type is needed)
   - Kind: Some "quickfix"
   - Diagnostics: Some [| diag |]
   - IsPreferred: Some false (not preferred -- informational only)
   - Edit: None (no auto-edit -- type errors require manual fixing)
   - Command: None, Data: None, Disabled: None
   - If the expected type cannot be parsed from the message, return None (skip creating an action)

3. `handleCodeAction (p: CodeActionParams) : Async<TextDocumentCodeActionResult option>`
   - Check p.Context.Diagnostics for fixable diagnostics
   - For each diagnostic with Source = Some "funlang":
     - If Code matches U2.C2 "unused-variable": create prefix underscore action
     - If Message contains "Type mismatch" or "expected": create type info action (ACTION-02)
   - Return type is `TextDocumentCodeActionResult` which is `U2<Command, CodeAction>[]`. Wrap each CodeAction in U2.C2:
     ```fsharp
     let result = actions |> Array.map U2.C2
     return Some result
     ```
   - Return None if no actions generated

**Server.fs** -- Complete registration:

1. Add opens: `open LangLSP.Server.Rename`, `open LangLSP.Server.CodeActions`
2. Add to serverCapabilities:
   ```fsharp
   RenameProvider = Some (U2.C2 {
       PrepareProvider = Some true
       WorkDoneProgress = None
   })
   CodeActionProvider = Some (U2.C2 {
       CodeActionKinds = Some [| "quickfix" |]
       ResolveProvider = Some false
       WorkDoneProgress = None
   })
   ```
3. Add to Handlers module:
   ```fsharp
   let textDocumentRename (p: RenameParams) : Async<WorkspaceEdit option> =
       Rename.handleRename p

   let textDocumentPrepareRename (p: PrepareRenameParams) : Async<PrepareRenameResult option> =
       Rename.handlePrepareRename p

   let textDocumentCodeAction (p: CodeActionParams) : Async<TextDocumentCodeActionResult option> =
       CodeActions.handleCodeAction p
   ```

**LangLSP.Server.fsproj** -- Add Rename.fs and CodeActions.fs to compile list. Final order must be:
```xml
<Compile Include="References.fs" />
<Compile Include="Rename.fs" />
<Compile Include="CodeActions.fs" />
<Compile Include="Diagnostics.fs" />
```

Rename.fs must be after References.fs (imports it). CodeActions.fs must be after Protocol.fs (imports createWorkspaceEdit). Diagnostics.fs must be after References.fs (imports collectReferences for findUnusedVariables).
  </action>
  <verify>
`dotnet build src/LangLSP.Server/` compiles without errors. All new modules linked. Server.fs has all 3 new capabilities registered (References from Plan 01, Rename, CodeAction).
  </verify>
  <done>
Rename.fs handles prepareRename (validates renameable symbol) and rename (builds WorkspaceEdit via source text name search). CodeActions.fs generates quickfix for unused variables (prefix underscore) AND informational action for type errors (show expected type). Diagnostics.fs detects unused variables with Warning severity and DiagnosticTag.Unnecessary. Server.fs registers RenameProvider (with PrepareProvider), CodeActionProvider (quickfix kind).
  </done>
</task>

</tasks>

<verification>
```bash
dotnet build src/LangLSP.Server/
# Must compile with 0 errors
# All modules linked: References, Rename, CodeActions
# Server capabilities: ReferencesProvider, RenameProvider, CodeActionProvider
```
</verification>

<success_criteria>
- Rename.fs correctly collects references + definition name span (via source text search) and builds WorkspaceEdit
- prepareRename validates cursor is on Var, Let, LetRec, Lambda, or LambdaAnnot
- Diagnostics.fs detects unused let-bound variables (not underscore-prefixed) with Warning severity and DiagnosticTag.Unnecessary
- CodeActions.fs generates "prefix with underscore" quickfix for unused variables (ACTION-01)
- CodeActions.fs generates informational "Expected type: X" action for type mismatch diagnostics (ACTION-02)
- All capabilities registered in Server.fs
- Project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-features/04-02-SUMMARY.md`
</output>
